# PROJECT CHEESE KING
#### Video Demo:  <URL HERE>
#### Description:
Jogo _2D de estilo Corrida infinita_ feito na linguagem de **lUA**, com assistencia da biblioteca **lUA ROCKS**, e em **LOVE**, alem de usar um arquivo **JSON** para armazenamento de dados referente ao jogador. O projeto apresenta diversos arquivos **.lua**, devido a escolha do desenvolvedor<sup>Thales Tenorio de Medeiros</sup> de tratar os elementos do jogo _(pessonagem, inimigo, obstaculos e colecionaveis)_ como objetos criados apartir de functions, aonde cada um inicia com posicionamentos, tamanhos e velocidades padrões ao serem criados e isto permitira a **main.lua** quando importar seus arquivos atraves de **require()** chamar suas functions e entâo criar o objeto dentro do jogo _(main.lua)_. Em suas function tambem esta presente sub-functions de ações como andar, pular e a de ser desenhado, ao qual tambem podem ser chamadas alterando as caracteristicas inicias de tal objeto ou apenas desenhando na tela, _exemplo: **Player[1]:move**, aonde Player é uma lista que armazena o obejto **Steve()** de **Steve.lua** que possui uma function chamada **move()** que altera ou o eixo X ou o Y do **Player[1]**_, além dos 'objects'.lua estão presentes o **SFX.lua**, o **conf.lua** e o **save.json** aonde o _SFX_ é um arquivo para gerenciamento de audio, permitindo adicionar, retirar audios do jogo e tambem alterar o volume do mesmo, quanto ao _conf_ inclusive é um nome de arquivo padrão utilizado para o arquivo que ira manipular as propriedades da janela do jogo como titulo, icone, tamanho de janela entre outros, em relação ao _save.json_ é um arquivo como antes dito para armazenamento, seu funcionamento é baseado na leitura e escrita simples de chaves e seus valores, aonde os dados devem ser importados para o codigo como uma lista ao qual podera ser manipulada dentro do codigo, e entao depois escrita no arquivo, o projeto apresenta tambem um arquivo chamado **Globals.lua** onde esta presente functions de utilidade tanto neste projeto quanto em outros, sendo uma de calculo matematico e duas para atalhos de abrir e fechar o arquivo Json, e por fim vale falar sobre a escolha da musica do jogo e dos sprites de todos objetos e do plano de fundo, em relação a musica a escolha foi feita na vontade de trazer a nostalgia dos jogos de arcades antigos, quanto aos sprites são todos de autoria propria, em desenhos feitos na infancia, houve unicamente a necessidade de completar os frames, o personagem principal e controlado pelo jogador se chama **Steve** sendo um rato, precisando desviar de obstaculos que são pedrinhas, enquanto coleta fatias de queijo e foge do inimigo chamado **Lunna** que é um cachorro. 

Com a introdução completa irei explicar como **main.lua** funciona, quando cada um dos outros arquivos de objetos é chamado e a interação de _main_ com **SFX.lua**, **conf.lua** e **save.json**, o arquivo main começa importando atraves de **require()** todos os outros arquivos me permitindo no momento que achar melhor trabalhar com eles, importo o arquivo de dados em uma variavel e em sequida salvo em outra variavel o primeiro valor da chave highscore(top 1 pontuação), além de iniciar mais 3 variaveis, uma para armazenar uma string com valor inicial de **""**, chamada **name**, uma para armazenar um numero **(time_init)**, sem valor inicial, outra **(time_space)** iniciada com o valor de _7.5_, e por ultima uma variavel que importa o **SFX()** importado de **sfx.lua**, depois uma sequencia de **tables** iniciando com uma table representando a introdução do jogo **(intros)**, com cinco chaves e seus valores sendo elas, **title** aonde tem o nome do jogo **Chesse King**, **logo** aonde tem o caminho para uma imagem desenhada _(autoria propia)_ de um queijo completo com uma coroa, presente na pasta **Cheese_King**, **creator** armazenando o nome do criador e desenvolvedor do jogo ,**space** e **pause** as duas chaves com contesto igual aonde _space_ tem um texto informando que a tecla 'space' do teclado faz o jogador pular e _pause_ possui um texto tambem informando que a tecla 's' pausa o jogo, logo em sequida uma **table game** com chaves de tudo relacionada ao jogo em si, como uma **table state** com todos os estado do jogo **intro1, intro2, menu, running, configurations, paused, pontuacao e ended**, sendo inicialmente _intro1_ true e os outros false, na _table game_ tem tambem points que ira contar a pontuação corrente enquanto running, uma lista com as pontuações necessarias para haver mudanças no jogo, **level_change** {50, 200, 500, 1000, 3000}, uma variavel chamada **high_score** servira para um maior controle em relação ao **dt(a medida de tempo usada em love em relação aos 60 fps)** e comparar com as pontuações do nosso banco de dados **Json**, tem tambem 6 variaveis relacionadas a deixar sortido a posição tanto das pedras(obstaculos) como dos queijos(colecionaveis), são elas **randominit_r, randomend_r e randomrock** para as pedras **randominit_c, randomend_c, randomcheese** para os queijos, para os queijos temos ainda tambem uma lista vazia **cheeses** ja que a intenção e fazer aparecer 5 queijos juntos, tem tambem a **cheese_space**, o espaço entre os queijos, com valor 6, tem a **cheese_icon** com o caminho de um desenho de fatia de queijo, presente na pasta **Cheese_King**, e a **cheese_round** que ira contar a quantia de queijo coletada em cada running separado, e por fim uma variavel importando o plano de fundo com parametro 0, **Background(0)** o plano de fundo ira iniciar no eixo x e y em 0, a proxima table é a **buttons** com uma lista vazia para cada state de game que tera pelo menos um botão, depois tem a table **mouse** que tem duas variaveis **mouse_x e mouse_y**, alem da function **Mouse()** importada de **mouse.lua**, e então temos as tables dos protagonistas do jogo **player** e **enemy** ambas importam seus objetos respectivos, _player_ importa o **Steve()** e o _enemy_ a **Lunna()** ambos possuem uma table chamada **animation** onde tem **idle** se esta parado ou não ambos começam em true, **frame** sprite atual ambos começam em 1, **max_frame** quantia maxima de sprite, _player_ tem 8 e _enemy_ 4 and **timer** que é o contador de tempo ambos iniciam em 0.1, _player_ possui mais dois timer **jump_timer** e **hit_timer** que são os contadores de tempo das chaves **jump** e **hit** que começam como false, ja _enemy_ possui tambem uma chave a mais chamada **callback** que começa com 0, e para termina o programa inicia 3 listas vazias **background_run**, **stone** e **coletavel** que iram armazenar o fundo que se move, os obstaculos e os colecionaveis respectivamente. Ainda antes de iniciar o **love.load**, **update** ou **draw** existem algumas functions de suporte em _main_ são elas **changeGameState(state)** que permite mudar o **game.state**(chave state da table game) para a que foi passada, tornando true a entre parenteses e false todas outras, tem tambem a **startNewGame()** que reseta e prontifica todos parametros de contagem para um novo jogo(running), sendo eles a variavel _name_ para "" novamente, **enemy.callback** para 0, exvazia novamente as tables _stone_, _coletavel_, _background_run_ e _game.cheeses_, diminui **game.difficult** para 1 novamente, **game.level_change[1]** para 50 novamente, chama a função _changeGameState("running")_ para mudar o estado de jogo para rodando, adiciona nas tabelas *background_run*, _stone_ e _coletavel_ um item respectivo a elas, o background por que é nescessario ja a fatia de queijo e a pedrinha por motivos de teste de funcionamento, deixa **game.cheese_space** em 6 novamente, chama a função reset em _Steve()_ com **player[1]:reset()**, que reseta tanto sua localização x/y como a localização de sua hitbox,ambas para a localização inicial, esta função é principalmente pelo eixo y que varia quando o personagem é solicitado para pular, então ao reiniciar o jogo enquanto o personagem pulava, não havera bugs, _startNewGame()_ reseta tambem as outras chaves de _player_ e _enemy_ **player.animation.jump** e **player.animation.hit** para false, todos **timers**(timer, jump_timer, hit_timer) de player e enemy para 0.1,  **player.animation.frame** e **enemy.animation_e.frame** para 1, atualiza a variavel que armazernava a pontuação top1 **high_score_value** com **file_data.pontuacao[1].high_score** que é o primeiro valor da chave *high_score* de **pontuacao** de *file_data* que como dito antes é a table que armazena os dados do arquivo _Json_, diferente de _Steve()_, _Lunna()_ não possui hitbox, então o reset dele em _starNewGame()_ é mais direto com **enemy[1].x** para -320, e por fim as ultimas alterações são na table _game_, **game.points** valor 0 para contar os pontos de uma nova run, *game.cheese_round* e *game.high_score* para 0 tambem, inicia **game.randominit_r** e **game.randominit_c** em 10, ja **game.randomend_r** em *game.level_change[1]*(50) e  **game.randomend_c** em *game.level_change[2]*(200) e por fim **game.randomrock** com valor de **math.random(game.randominit_r, game.randomend_r)**(valor aleatorio entre 10 e 50) e **game.randomcheese** com valor **math.random(game.randominit_c, game.randomend_c)**(valor aleatorio entre 10 e 200), lembrando como são 5 queijos tem um loop de 1 a 5(repete cinco vezes) com **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)))**(apos o primeiro numero ser escolhido, digamos que 180, ao ser inserido na tabela *game_cheeses* o primeiro sera 180 mais 6 vezes (1 menos 1), e assim por diante, presevando o primeiro numero como o selecionado 180 e o restante mais 6 vezes(2 - 1), vezes(3 - 1), vezes(4 - 1), vezes(5 - 1)),isto é tudo de _startNewGame()_, outra função assitente é a **save()** nela sera inserido na tabela **file_data.pontuacao** tanto a variavel _nome_ e *game.high_score* logo apos tem uma função de tabela padronizada de lua **table.sort(file_data.pontuacao, function(a, b) return a.high_score > b.high_score end)** que permite organizar a tabela, de dois em dois valores se o primeiro maior que o segundo, retorna o primeiro se não retorna o segundo e quem restou forma par com o proximo, assim organizando em ordem decrescente, apos a organização verifica se o tamanho da tabela é de 4, se for apaga os dados de posição 4 na tabela, assim permanecendo nos top3 sempre, e por fim salva em **file_data.queijo** a soma do proprio valor mais **game.cheese_round** que é a quantia de queijos da ultima run, depois disto escreve toda table **file_data** no arquivo_Json_ com **write("save", file_data)** e então **changeGameState("ended")**, a proxima função assistente chamada **credit()** é bem basica, ela apenas armazena em *time_init* o tempo atual, **love.timer.getTime()**, e **changeGameState("intro1")**, e por fim uma função disponivel por _LOVE_ para ações do mouse, **love.mousepressed(x, y, button, istouch, presses)**, para evitar perda de tempo verificando enquanto _game.state["running"]_, **if not game.state["running"]**, e então caso não, apartir da condição **button == 1** se houve click do botão esquerdo do mouse(primario), ele ira verificar se esta em _menu_, _configurations_, _paused_, _pontuacao_ ou _ended_ e então apartir de um loop ira verificar o checkPressed() de cada botão na lista correspodente ao state, **if game.state["menu"]** então **for index in pairs(buttons.menu_state)** verifica **buttons.menu_state[index]:checkPressed(x, y, mouse[1].radius)**, sendo x e y as localizações do mouse ja oferecida pela função e _mouse[1].radius_ a hitbox do mouse, ja que ele possui uma camuflagem de uma fatia de queijo em forma de cursor, por escolha estetica, isso é tudo sobre as funções de assistencia em _main_, mas antes de ir para **love.load()**, irei explicar como a function **button:checkPressed()** funciona, **checkPressed = function(self, mouse_x, mouse_y, mouse_radius)**, como visto antes *mouse_x* equivale ao x do mouse, *mouse_y* ao y do mouse e *mouse_radius* a _mouse[1].radius_ que é a hitbox do cursor, recebendo estes parametros ele é capaz de calcular atraves de umna formula matematica tambem presente em _Globals.lua_ so que modificada, ja que a de _Globals_ calcula o encontro de duas hitbox circulares **calculateDistance(x1, y1, x2, y2)**, **dist_x = (x2 - x1) ^ 2**, **dist_y = (y2 - y1) ^ 2** e retornando **math.sqrt(dist_x + dist_y)**, e a de _Button_ calcula entre uma circular, hitbox do mouse, e uma rectangular o proprio botão em si, usando para a largura, **se (mouse_x + (mouse_radius * 3) >= self.button_x)** e **(mouse_x - mouse_radius <= self.button_x + self.width)**, e para a altura **se (mouse_y + mouse_radius >= self.button_y)** e **(mouse_y - mouse_radius <= self.button_y + self.height)** se ambos forem correto o ponta da fatia de queijo que funciona de cursor esta encima do botão, e junto ao click como dito antes, então a função atrelada ao botão ira funcionar, mas caso o botão não tenha função o botão não realizará nada. Ao termino das funções esta o corpo do arquivo _main.lua_ em **LOVE**, **load()** que é o menor dos tres, trabalha com as atualizações estaticas e que devem ser iniciadas ao executar o jogo, sendo elas a criação dos botões e adição a suas respectivas listas de acordo com o state do jogo que ira aparecer(**buttons.menu_state.play_game = Button("play game", startNewGame, nil)**, onde será criado um botão na lista de botões **menu_state** com nome **play_game**, o botão por sua vez sendo uma função em **Button.lua** recebe tres parametros, **function Button (text, func, func_param)**, seu texto, a função que ira realizar no _checkPressed()_ e caso tenha algum parametro para esta função o recebe tambem, sendo assim o botão *play_game* do menu do jogo, tem escrito play game e ao ser clicado ira iniciar um novo jogo atraves de _startNewGame()_), ao total são quatro botões para o **menu_state**, sendo eles **play game**, **settings** que _changeGameState_ para "configutations", **credits** que recebi _credit()_ e **exit game** que recebi **love.event.quit** uma função de _LOVE_ que para de a atual execução, tem também tres botões de **pontuacao_state** sendo **name:** sem função, um botão com a **variavel string _nome_** sem função tambem, ambos são botões por escolha estetica e o ultimo botão é o de **confirm** iniciado sem função, mas que ganha uma em **love.update()**, **ended_state** possui tres botões também sendo **replay game** com _starNewGame_, **menu** com _chageGameState()_ para "menu" e **exit game** também com mesmo atributos do com o mesmo nome em _menu_, em **paused_state** temos quatro botões, **resume** que _changeGameState_ para "running", **replay game**, **menu** e **exit** iquais aos outros botões de mesmo nome, apenas em outro state, e por fim os botões de **configurations_state** que são, **play_Stop_audio**, inicialmete aqui com nada escrito e sem funções, **Audio:** outro botão apenas estetico, uma sequencia de botões com texto **1 á 5**, todos com **changeVolume** com parametros _0.1_, _0.2_, _0.3_, _0.4_ e _0.5_ respectivamente, e o ultimo botão sendo o **back** com _changeGameState_ para "menu", outras alterações em _load_ são deixar o cursor original invisivel com **love.mouse.setVisible(false)** e adicionar o tempo inicial da execução, ja que existe a intro do jogo, em *time_init* com **love.timer.getTime()**. 