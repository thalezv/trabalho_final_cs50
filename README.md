# PROJECT CHEESE KING
#### Video Demo:  https://www.youtube.com/watch?v=qlH_b7rC3q8
#### Description:
##### Introduction:
_2D Infinite Race style game_ made in the **lUA** language, with assistance from the **lUA ROCKS** library, and in **LOVE**, in addition to using a **JSON** file to store related data to the player. The project presents several **.lua** files, due to the choice of the developer<sup>Thales Tenorio de Medeiros</sup> to treat the game elements _(character, enemy, obstacles and collectibles)_ as objects created from of functions, where each one starts with default positions, sizes and speeds when created and this will allow **main.lua** when importing your files through **require()** to call your functions and then create the object within the game _(main.lua)_. Its function also presents sub-functions for actions such as walking, jumping and being drawn, which can also be called by changing the initial characteristics of such an object or just by drawing on the screen, _example: **Player[1]:move**, where Player is a list that stores the **Steve()** object of **Steve.lua** that has a function called **move()** that changes either the X or Y axis of the **Player[1]**_, in addition to 'objects'.lua, there are **SFX.lua**, **conf.lua** and **save.json** where _SFX_ is a file for audio management, allowing you to add, remove audio from the game and also change its volume, as for _conf_ it is also a standard file name used for the file that will manipulate the properties of the game window such as title, icon, window size among others, in relation to _save.json_ it is a file as previously mentioned for storage, its operation is based on the simple reading and writing of keys and their values, where the data must be imported into the code as a list that can be manipulated within the code, and then written to the file, the project also presents a file called **Globals.lua** where utility functions are present both in this project and in others, one for mathematical calculation and two for shortcuts to open and close the Json file, and finally it's worth talking about the choice of the game's music and the sprites of all the objects and the background, in relation to the music the choice was made in the desire to bring the nostalgia of old Arcade games, As for the sprites, they are all my own creation, in drawings made in childhood, there was only a need to complete the frames, the main character is controlled by the the player's name is **Steve**, being a mouse, needing to avoid obstacles that are pebbles, while collecting slices of cheese and running away from the enemy called **Lunna**, who is a dog.
##### Project body:
###### Additional variables and functions:
With the full introduction I will explain how **main.lua** works, when each of the other object files are called and the interaction of _main_ with **SFX.lua**, **conf.lua** and ** save.json**, the main file starts by importing all the other files using **require()**, allowing me to import the data file in a variable and then save it in another variable when I think it's best to work with them. the first value of the highscore key(top 1 score), in addition to starting 3 more variables, one to store a string with an initial value of **""**, called **name**, one to store a number **( time_init)**, with no initial value, another **(time_space)** starting with the value of _7.5_, and finally a variable that imports **SFX()** imported from **sfx.lua** , then a sequence of **tables** starting with a table representing the introduction of the game **(intros)**, with five keys and their values, **title** which has the name of the game **Chesse King**, **logo** where there is the path to a drawn image _(own authorship)_ of a cheese complete with a crown, present in the folder **Cheese_King**, **creator** storing the name of the creator and game developer, **space** and **pause** the two keys with the same contest where _space_ has a text informing that the 'space' key on the keyboard makes the player jump and _pause_ also has a text informing that the key 's' pauses the game, then a **table game** with keys for everything related to the game itself, like a **table state** with all the game states **intro1, intro2, menu, running , configurations, paused, score and ended**, initially being _intro1_ true and the others false, in the _table game_ there are also points that will count the current score while running, a list with the scores needed to make changes in the game, **level_change** {50, 200, 500, 1000, 3000}, a variable called **high_score** will serve for greater control over **dt (the time measurement used in love in relation to 60 fps)** and compare with the scores from our **Json** database, there are also 6 variables related to sorting the position of both the stones (obstacles) and the cheeses (collectibles), they are **randominit_r, randomend_r and randomrock** to the stones **randominit_c, randomend_c, randomcheese** for the cheeses, for the cheeses we also have an empty list **cheeses** since the intention is to make 5 cheeses appear together, there is also the **cheese_space**, the space between the cheeses, with value 6, has the **cheese_icon** with the path of a cheese slice design, present in the folder **Cheese_King**, and **cheese_round** which will count the amount of cheese collected in each separate run, and finally a variable importing the background with parameter 0, **Background(0)** the background will start at x and y axis at 0, the next table is **buttons** with an empty list for each game state that will have at least one button, then there is the **mouse** table which has two variables **mouse_x and mouse_y**, in addition to the function **Mouse()** imported from **mouse.lua**, and then we have the tables of the game's protagonists **player** and **enemy** both import their respective objects, _player_ imports **Steve()** and _enemy_ a **Lunna()** both have a table called **animation** where there is **idle** whether it is stopped or not both start at true, **frame** current sprite both start at 1, **max_frame** maximum amount of sprite, _player_ has 8 and _enemy_ 4 and **timer** being the time counter both start at 0.1, _player_ has two more timer **jump_timer** and **hit_timer** being the time counters of the **jump** and **hit** keys that start with false, _enemy_ also has an additional key called **callback** that starts with 0, and for The program ends and starts 3 empty lists **background_run**, **stone** and **collectable** that will store the moving background, obstacles and collectibles respectively. Even before starting **love.load**, **update** or **draw** there are some support functions in _main_ they are **changeGameState(state)** which allows you to change **game.state**(state key of the table game) for the one that was passed, making true in parentheses and false all others, there is also **startNewGame()** which resets and makes all counting parameters ready for a new game(running ), being the variable _name_ to "" again, **enemy.callback** to 0, empty the tables _stone_, _coletavel_, _background_run_ and _game.cheeses_ again, decrease **game.difficult** to 1 again, ** game.level_change[1]** to 50 again, calls the _changeGameState("running")_ function to change the game state to running, adds an item corresponding to them to the *background_run*, _stone_ and _coletavel_ tables, the background by which is necessary, as for the slice of cheese and the pebble for function test reasons, leave **game.cheese_space** at 6 again, call the reset function in _Steve()_ with **player[1]:reset( )**, which resets both your x/y location and the location of your hitbox, both to the initial location, this function is mainly due to the y axis that varies when the character is asked to jump, so when restarting the game while the character was jumping, no there will be bugs, _startNewGame()_ also resets the other keys of _player_ and _enemy_ **player.animation.jump** and **player.animation.hit** to false, all **timers**(timer, jump_timer, hit_timer ) of player and enemy to 0.1, **player.animation.frame** and **enemy.animation_e.frame** to 1, updates the variable that stored the top1 score **high_score_value** with **file_data.pontuacao[ 1].high_score** being the first value of the *high_score* key of **score** of *file_data* which, as said before, is the table that stores the data from the _Json_ file, different from _Steve()_, _Lunna() _ does not have a hitbox, so resetting it in _starNewGame()_ is more direct with **enemy[1].x** to -320, and finally the last changes are in the _game_ table, **game.points** value 0 to count the points of a new run, *game.cheese_round* and *game.high_score* to 0 too, starts **game.randominit_r** and **game.randominit_c** at 10, already **game. randomend_r** in *game.level_change[1]*(50) and **game.randomend_c** in *game.level_change[2]*(200) and finally **game.randomrock** with a value of **math.random(game.randominit_r, game.randomend_r)**(random value between 10 and 50) and **game.randomcheese** with value **math.random(game.randominit_c, game.randomend_c)**(value random between 10 and 200), remembering how there are 5 cheeses, there is a loop from 1 to 5 (repeats five times) with **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)) )**(after the first number is chosen, let's say 180, when inserted into the *game_cheeses* table the first will be 180 6 more times (1 minus 1), and so on, preserving the first number as the selected 180 and the remainder plus 6 times(2 - 1), times(3 - 1), times(4 - 1), times(5 - 1)), that's all from _startNewGame()_, another helper function is **save()** will be inserted into the table **file_data.pontuacao** both the variables _nome_ and *game.high_score* then have a standardized lua table function **table.sort(file_data.pontuacao, function(a, b) return a.high_score b.high_score end)** that allows you to organize the table, for every two values ​​if the first is greater than the second, returns the first if the second is not returned and whoever remains forms a pair with the next, thus arranging in descending order, after the organization checks if the size of the table is 4 , if you delete the data from position 4 in the table, thus always remaining in the top3, and finally save in **file_data.queijo** the sum of the value itself plus **game.cheese_round** which is the amount of cheese in the last run, after this writes the entire table **file_data** into the_Json_ file with **write("save", file_data)** and then **changeGameState("ended")**, the next helper function called **credit( )** is very basic, it just stores in *time_init* the current time, **love.timer.getTime**, and **changeGameState("intro1")**, and finally a function available by _LOVE_ for actions of mouse, **love.mousepressed(x, y, button, istouch, presses)**, to avoid wasting time checking while _game.state["running"]_, **if not game.state["running" ]**, and then if not, from the condition **button == 1** if there was a click of the left mouse button (primary), it will check if it is in _menu_, _configurations_, _paused_, _pontuacao_ or _ended_ and then from a loop it will check the checkPressed() of each button in the list corresponding to the state, **if game.state["menu"]** then **for index in pairs(buttons.menu_state)** checks **buttons.menu_state[index]:checkPressed(x, y, mouse[1].radius)**, with x and y being the mouse locations already offered by the function and _mouse[1].radius_ being the mouse's hitbox, since it has a camouflaging a slice of cheese in the form of a cursor, by aesthetic choice, this is all about the assistance functions in _main_, but before going to **love.load()**, I will explain how the function **button:checkPressed()** works, **checkPressed = function(self, mouse_x, mouse_y, mouse_radius)**, as seen before *mouse_x* is equivalent to the x of the mouse, *mouse_y* to the y of the mouse and *mouse_radius* to _mouse[1].radius_ which is the cursor's hitbox, receiving these parameters it is able to calculate through a mathematical formula also present in _Globals.lua_ but modified, since that of _Globals_ calculates the meeting of two circular hitboxes **calculateDistance(x1, y1, x2 , y2)**, **dist_x = (x2 - x1) ^ 2**, **dist_y = (y2 - y1) ^ 2** and returning **math.sqrt(dist_x + dist_y)**, and a of _Button_ calculates between a circular, mouse hitbox, and a rectangular button itself, using for the width, **if (mouse_x + (mouse_radius * 3) = self.button_x)** and **(mouse_x - mouse_radius = self.button_y)** and **(mouse_y - mouse_radius <= self.button_y + self.height)** if both are correct, the tip of the cheese slice that serves as the cursor is on top of the button, and next to the click As said before, then the function linked to the button will work, but if the button has no function, the button will not do anything.
###### Love.load:
At the end of the functions is the body of the _main.lua_ file in **LOVE**, **load()** being the smallest of the three, works with static updates and which must be started when running the game, these being the creation of buttons and addition to their respective lists according to the state of the game that will appear (**buttons.menu_state.play_game = Button("play game", startNewGame, nil)**, where a button will be created in the list of **menu_state** buttons with name **play_game**, the button in turn being a function in **Button.lua** receives three parameters, **function Button (text, func, func_param)**, its text , the function that will perform in _checkPressed()_ and if there is any parameter for this function also receives it, so the *play_game* button on the game menu has play game written on it and when clicked it will start a new game through _startNewGame()_), in total there are four buttons for the **menu_state**, namely **play game**, **settings** and _changeGameState_ for "configutations", **credits** that I received _credit() _ and **exit game** that I received **love.event.quit** a _LOVE_ function that stops the current execution, it also has three **punctuation_state** buttons with **name:** having no function, a button with the **variable string _name_** without a function either, both are buttons by aesthetic choice and the last button is the **confirm** button started without a function, but which gains one in **love.update()**, **ended_state** has three buttons also being **replay game** with _starNewGame_, **menu** with _chageGameState()_ for "menu" and **exit game** also with the same attributes as with the same name in _menu_, in **paused_state** we have four buttons, **resume** that _changeGameState_ for "running", **replay game**, **menu** and **exit** same as the other buttons of the same name, only in another state, and finally the **configurations_state** buttons which are, **play_Stop_audio**, initially here with nothing written and without functions, **Audio:** another button just aesthetic, a sequence of buttons with text **1 to 5**, all with **changeVolume** with parameters _0.1_, _0.2_, _0.3_, _0.4_ and _0.5_ respectively, and the last button being **back** with _changeGameState_ for "menu", other changes in _load_ are to make the original cursor invisible with **love.mouse.setVisible(false)** and add the initial execution time, since there is the game's intro, in * time_init* with **love.timer.getTime()**.
###### Love.update:
Next we have **love.update(dt)** as the second base function of _LOVE_, responsible for updates throughout the execution time, using **dt(delta time)** as a parameter, which would be the representation of frames per second, but due to current processors the value is represented more or less by 0.013, so that the mouse skin will always be wherever it is every second, **mouse.mouse_x, mouse.mouse_y = love.mouse. getPosition()** independent of _state_, as seen the game has two command keys and a third for writing in _pontuacao_ (backspace), for greater control, two of them only work when releasing the key, using the **love function. keyreleased(key)** where key will be the key, **if key == "space" and player.animation.jump == false and player.animation.hit == false and game.state["running"]** , that is, to jump it is necessary to release the key when the character is not in the middle of a jump or hit and obviously the game is in _running_, so **player.animation.frame = 1**(resets frame since they are shared walking and jumping), **player.animation.idle = true** and **player.animation.jump = true**(indicate that it is a jump and not walking) and the second key **if key == "backspace" and game.state["punctuation"]** when the backspace key known for erasing text is released while the game is in _punctuation_, then **name = string.sub(name, 1, -2)**( the string _nome_ through **string.sub** which allows you to manipulate a string, cutting a new string from another, a normal string goes from 1 to -1, when putting 1 to -2 the new string will have all the characters except the last and when saving in _name_ it overwrites the change, giving the sensation that the last digit has been deleted), after these changes, the next ones are divided into _states_, **if game.state["intro1"]** then a variable called ** time_count** will store the time with **love.timer.getTime()** and due to being in the update this will happen every second if at any point **time_count - time_init** is greater than or equal to *time_space* (7.5 seconds) so firstly **time_init = time_count** and **changeGameState("intro2")**, after that comes **if game.state["intro2"]** then again *time_count* will store the time every second and **if time_count - time_init** is greater than or equal to *time_space* again then this time **changeGameState("menu")**, changing from the intros to the menu depends only on the time, then it will be for buttons or the player's defeat in "running", so the next one is **if game.state["running"]** then it starts indicating that both the player and the enemy are walking with **player.animation.idle = false** and **enemy.animation_e.idle = false**, the next update per second without condition beyond the "running" state, is the point count **game.points = game.points + (dt * 8)** o value of dt * 8 is as close to 1 per second as possible, so this calculation causes _game.points_ to increase by 1 for each second of "running" that passes, I thought it was important that the next condition was the player's defeat , which is **if enemy[1]:kill()**(the **kill()** function present in _Lunna()_, due to the enemy not having a hitbox only returns true **if self.x == -120** and false if not) then it will check **if game.high_score** greater than **high_score_value**(first place in Json) or greater than **file_data.pontuacao[2].high_score** or that **file_data.pontuacao[3].high_score**(second and third places), but before asking about second and third **#file_data.pontuacao** less than 3 (if the score size is still smaller than 3), all these options **changeGameState("punctuation")**, but if you have three high_score and they are all higher than the current one then **changeGameState("ended")**, in addition to saving the amount of cheese from the current one "running" in Json with **file_data.queijo = file_data.queijo + game.cheese_round**, **write("save", file_data)** and again import the data for security reasons **file_data = read(" save")** and finally if _kill_ returns false, **enemy[1]:move(player.animation.hit, dt, enemy.callback)**(the move function in _Lunna_ works based on two internal parameters of the location of x, and influence of the player's hit, dt and callback, where **if not hit** then it will do two different things, **if self.x** greater than -660 (enemy's retreat limit) and * *cb == 0** then **self.x = self.x - dt * 200**[moves from right to left, eventually disappearing from the screen], now if mainly **cb** is greater than 0 then ** self.x = self.x**[remains in place], but if there is a _hit from the player then **if self.x** is less than -120[advance limit, remembering that -120 is _kill_] then ** self.x = self.x + dt * 200** the enemy advances, reappearing on the screen), then we check all the objects in the *background_run*, _coletavel_ and _stone_ lists to make some changes and mainly trigger the _move_ of each one, starting with the simplest, a loop from 1 to **#stone**(list size), **stone[l]:move(dt, player.animation.jump)**(remembering that the maximum difficulty and 8, where the speed of the stone is **20 * level** if less than 8 and if greater **20 * 8**, as the jump at level 1 is unable to pass the stone, but I thought it was the ideal starting speed so the _move_ has two options **if I jump** (character jumped) and **self.lvl** less than 2 then both the stone itself **self.x** and its hitbox **self.circle_x** will be equal to the same **- self.speed * (dt * 25) - self.lvl** and if it is not jumping on the level 1, that is, greater than or equal to level 2 whether jumping or not then both will be decreased by **- self.speed * (dt * 10) - self.lvl**, both the first and second options the stone will appear due to the parameters of the object itself at the end of the screen on the right and will move depending on these **ifs** of _move_ and the **game difficulty** to the far left of the screen), for the _collectable_ list it is basically the same in _move_ of _Cheese_, and when using from 1 to **#coletavel** do **coletavel[i]:move(dt, player.animation.jump)**, the only difference is that the cheese has a peculiarity by visual option, of **if calculateDistance(stone[j].circle_x, stone[j].circle_y, collectable[i].circle_x, collectible[i].circle_y)** less than or equal to **collectable[i].radius * 2**(hitbox of the cheese and some stone present in the _stone_ list are overlapping) then both **coletavel[i].y** and **coletavel[i].circle_y** will decrease by themselves - 10 as and an _if_ in _update_ will happen until they are no longer overlapping, in short, the cheese that appears in the same place on the stone will be ejected onto it, at a speed imperceptible to human eyes, and finally the *background_run* list, will check accordingly 1 to its size, initially creates and stores in **background_value** **CalculateComplement(background_run[a].totalwidth, background_run[a].width)** the _globals.lua_ function that serves to know the rest of the background that is off screen, so **if background_run[a].x** greater than **background_value**, and less than **background_value + background_run[a].speed * (dt * 10)**(the off-screen value plus the background speed in one unit, to get the lowest possible value in which the background has nothing off-screen, taking into account the speed of your movement regardless of the difficulty) then **table_insert(background_run, BackGround(love.graphics.getWidth() - 1))**(inserts a new background into the list, at the end of the screen) and as long as the character is not reached then **background_run[a]:move(dt)** , the **dt** of _update_ is excellent for working with frames, and sequential or quick updates, but for singular updates it ends up presenting a problem, my solution was to add these singular updates within another recurring update, in this case **se math.floor (game.points)** greater than **game.high_score** then **game.high_score = math.floor(game.points)**, recurring update to the highscore of the current "running", but when the condition is filled in does not do anything else until what is inside is completed, by adding individual updates inside it, it allows you to only activate it once, which is an example of changes to the game running, starting with **if math.floor(game. points) % game.level_change[2] == 0**(the symbol % is used to find the remainder of a division, therefore all multiples of *level.change[2]*) and, in addition, also less than * *game.level_change[4]** then decreases **game.level_change[1]** by 5, **game.cheese_space** by 1 and increases **game.difficult** by 1, and to prevent bugs do the same as with the objects still existing in the lists **game.cheeses**, **stone** and **coletavel**, **if math.floor(game.points)** is greater than **game .level_change[4]**, less than **game.level_change[5]** and **math.floor(game.points) % game.level_change[3] == 0** then the difficulty increases by 1, **game.level_change[1]** decreases by 2 and **if game.difficult** is less than 8 then it regulates the difficulty of objects in the **stone** and **collectible** lists, and last change " in game", **if math.floor(game.points)** greater than **game.level_change[5]** and **math.floor(game.points) % game.level_change[4] == 0** decreases **game.level_change[1]** by 1 with restriction, to keep the game balanced, for *game.level_change[1]* it can only be decreased to 11, now in relation to the addition of stones and cheese both check **if math.floor(game.points)** is equal to its corresponding _game.random_ and then stores **math.floor(game.points)** in _game.randominit_ and for stone **game.randomend_r = game .randominit_r + game.level_change[1]**, for cheeses **game.randomend_c = game.randominit_c + game.level_change[2]**, calculates new _random_ values, but with a condition that for stones **game.randomrock - game.randominit_r** is greater than 10 through a **While** loop to prevent the new stone from having a very small distance in relation to the previous one, and for the cheese the same being that in its _while_ **game.randomcheese - game.randominit_c** must be greater than 50, after a satisfactory _random_ value, and as for the corresponding function, the stones add one to the _stone_ list, for the cheeses, through a loop from 1 to 5, **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)))** and to finish what is in the points check, a loop for all values ​​in the list of _game.cheeses_ **s and math.floor(game.points)** is equal to **game.cheeses[i]** then **table.insert(coletavel, Queijo(game.difficult))** and to keep the list with only what is necessary **table.remove(game.cheeses, game.cheeses[i])**, after all this we have another type of check for the keyboard, **if love.keyboard.isDown("s")**(when the key is pressed, in this case the "s" ) then changes the game state to "paused", then a check again on all objects in the _coletavel_ and _stone_ lists where **if calculateDistance(player[1].circle_x, player[1].circle_y, object[i]. circle_x, object[i].circle_y)** is smaller than **object[i].radius * 2** (object can be either stone or collectible, it checks if the player's hitbox meets that of a stone or of a cheese) and for collectibles **and not player.animation.hit** (visual choice the character does not pick up cheese if hit), for stones, it is removed from the list, and the player's frame is reset to 1, and its state is changed to **hit = true** and **enemy.callback = 1** (currently hit and the enemy, after moving, will remain still), for cheeses, they will also be removed from your list, but **game.cheese_round = game.cheese_round + 1**, in both checks it also has the condition if the object leaves the screen **if object[i].x** less than **0 - object[ i].radius * 3**(being an object or collectible or stone), both will be deleted from their respective list, but in stones, **enemy.callback = 0** (when jumping over a stone Steve runs away from Lunna), and to finish what happens in " running", we have the frame changers for each animation with their time based on _dt_, where for each **player.animation.** and **enemy.animation_e.idle** the timer for each of these animation states is added + dt, for example **enemy.animation_e.timer = enemy.animation_e.timer + dt**, when this timer reaches 0.4 and 0.25 for _enemy_(more frantic animation), the _timer_ is reset and the number of frames increases by 1, case for player in _hit_ to reach *max_frames*, the frame resets to 7, hit to false and idle to false, while in _jump_ it needs to reach *max_frames/2*, resets frame to 6, jump false and idle false, and in _idle_'s _animation_ it only resets the frames to 4 (1 to 3, these are race start frames, the race loop is between 4 to 8), for *enemy.animation_e.max_frames* it returns to frame 1, as next updates are in **se game.state["punctuation"]** where the _LOVE_ function is responsible for taking the player's input when writing their name, **love.textinput(t)**, ** if #nome** less than 6 **and game.state["punctuation"]**(as input is a function that, once activated, becomes permanently active, and I need to reaffirm that it should only work when it is in "punctuation" and for a reason logistics the name must be less than 6, but accepts numbers, letters and symbols) then **name = name .. t**(will add the string name, the player input), updates the buttons **buttons.pontuacao_state .nameinput = Button(nome, nil, nil)** to display this name in real time, and **if #name 0** (if the player does not type anything, it will not trigger a function for the confirm button) then **buttons.pontuacao_state.confirm = Button("confirm", save, nil)**, otherwise the button will have the same text, but will not perform any action, in **game.state["configurations"]**, we have the music button update where **if not audio:playing_BGM()**(there is no music playing) then **buttons.configurations_state.play_Stop_audio = Button("Play", changeAudio, nil)**(the button will activate it) otherwise **buttons.configurations_state.play_Stop_audio = Button("Stop", changeAudio, nil)**(will stop it) and before **love.draw**, **if game.state[ "paused"]** or **game.state["ended"]** or **game.state["punctuation"]** then stops updating the score, highscore and idle of the player and enemy remain true, stopping the movement of both.
###### Love.draw:
Lastly we have **love.draw()**, after all we have already created variables and functions, loaded buttons, updated these variables, functions and buttons according to our wishes, but all of this is happening outside the player's eyes, _draw_ is responsible for what will actually appear on the screen visually, again we will divide by the game state, but first **game.background:draw()**(static background will be in all states), **love.graphics.printf("FPS :." .. love.timer.getFPS(), love.graphics.newFont(16), 10, 10, love.graphics.getWidth())**(the function _LOVE_, **getFPS** allows you to see the fps of the love application that is running, in a font size 16, with axis x = 10 and y = 10, regardless of state), and then **if game.state["intro1"]** then it will draw **love. graphics.draw(intros.logo, love.graphics.getWidth() / 3, -100)**(**graphics.draw** is used to draw an image, in this case the image of _intros.logo_, x axis=* *getWidth()** is used to get the width of the application window, /3, due to the image property this value will cause the image to be centered horizontally, y axis = 100) and below the game logo is named with **love.graphics.printf(intros.title, love.graphics.newFont(50), love.graphics.getWidth() / 2.7, 250, love.graphics.getWidth())**(after axis x and y, it is possible to place a control parameter in the case **love.graphics.getWidth()**, used to center texts) and finally the mouse, **mouse[1]:draw(mouse.mouse_x, mouse.mouse_y )**, in **if game.state["intro2"]** then **love.graphics.setColor(0, 0, 0)**(changes the color of text, and drawings that use shapes, in addition to add a visual layer of this color over images, use the RGB scheme, in this case the color black) with this color **love.graphics.printf("creator: " .. intros.creator, love.graphics.newFont(30), love.graphics.getWidth() / 3.5, 50, love.graphics.getWidth())**(writes the name of the creator indicated that this is the creator, joining a string with **intros.creator** which also has a string ), **love.graphics.printf("In Game", love.graphics.newFont(30), love.graphics.getWidth() / 2.5, 110, love.graphics.getWidth())**(just below, visual information for the player), then enter the information to play using **printf**, **.graphics.printf(intros.space, love.graphics.newFont(30), love.graphics.getWidth () / 3.8, 200, love.graphics.getWidth())**(write information from **intros.space**), **love.graphics.printf(intros.pause, love.graphics.newFont(30 ), love.graphics.getWidth() / 1.8, 200, love.graphics.getWidth())**(the information from **intros.pause**), returns the color to white (default), **love. graphics.setColor(1, 1, 1)** and draws the mouse again, **if game.state["running"]**, it will draw all the backgrounds of *background_run* using **background_run[l] :draw()**(where in a loop from 1 to **self.var** where _self.var_ **math.ceil(_totalwidth / _width)**), then **love.graphics.draw(self. sprite, self.x + (self.width * (i - 1)), self.y)**(it will draw sprites until the screen is covered by the backgrounds, 2 are needed, remembering that the x axis is given in update, being 0 in static and at the beginning and end of the window for the next ones, and the y axis is always 0), draws the score **love.graphics.printf(math.floor(game.points), love.graphics .newFont(24), 0, 10, love.graphics.getWidth(), "center")** at the top of the screen centered, through the last two parameters, then **love.graphics.push()** serves to save more dynamic changes to *graphics*, in this case it is saving the default settings, and then **love.graphics.scale(0.5, 0.5)** (changes the scale of everything twice as small), **love.graphics .draw(game.cheese_icon, love.graphics.getWidth() * 1.7, -90)**(draws an image of a cheese, to count), and then uses **love.graphics.pop()** which serves to return the _graphics_ settings, to the _push()_ closer, thus disabling the _scale_, **love.graphics.printf(":" .. " " .. game.cheese_round, love.graphics.newFont(16 ), love.graphics.getWidth() - 120, 20, love.graphics.getWidth())**, writes the cheese value of the current "run", after the cheese drawing and separated by ":", then draws the objects from the _coletavel_ and _stone_ lists with their respective _draw()_ functions, being the object and its hitbox, on the x-axis, off-screen to the right and y-axis a little above the end of the screen and then draws the player and the enemy, **player[1]:draw(player.animation.frame, player.animation.jump, game.state["paused"], player.animation.hit)**, **enemy[1]:draw( enemy.animation_e.frame)**(both receive the frame as a parameter, to know the **quad** that should be used, **NewQuad()** is a _LOVE_ function that allows you to divide an image into pieces of it, dividing the sprite we get the frames), player already receives other parameters because while _not idle_ uses **self.quads[frames]**, if _hit_ uses **self.sprite3** (hit sprite only has one image), and if _jump_ uses **self. quads2[frames]**, then we have **if game.state["menu"]** then draw the buttons from *menu_state*, **buttons.menu_state.play_game:draw(20, 40, 45, 15)**, **buttons.menu_state.settings:draw(20, 100, 45, 15)**, **buttons.menu_state.creditos:draw(20, 160, 45, 15)** and **buttons.menu_state .exit_game:draw(20, 220, 45, 15)**, one below the other due to the change only in the y axis, and then draws the cheese on a 2x smaller scale along with the total amount of cheeses on the account, and ends by drawing the mouse, **if game.state["configurations"]** draws the *configurations_state* buttons, **buttons.configurations_state.play_Stop_audio:draw(20, 40, 45, 15)**, and then the volume below play, but next to each other, **buttons.configurations_state.audio:draw(20, 100, 45, 15)**, **buttons.configurations_state.one:draw(120, 100, 45, 15 )**, **buttons.configurations_state.two:draw(220, 100, 45, 15)**, **buttons.configurations_state.three:draw(320, 100, 45, 15)**, **buttons. configurations_state.four:draw(420, 100, 45, 15)** and **buttons.configurations_state.five:draw(520, 100, 45, 15)**, below them the button to return to the **buttons menu. configurations_state.back:draw(20, 160, 45, 15)**, and finally the mouse, **if game.state["punctuation"]** then draws all stones, cheeses and the enemy, as score is the moment of the player's defeat, it does not appear due to aesthetic choice, it draws the *pontuacao_state* buttons, **buttons.pontuacao_state.name:draw(love.graphics.getWidth() / 2.3, 80, 45, 15)**, **buttons.pontuacao_state.nameinput:draw(love.graphics.getWidth() / 2.0, 80, 45, 15)** and **buttons.pontuacao_state.confirm:draw(love.graphics.getWidth() / 2.3, 140, 45, 15)** and writes the current score, along with the score and name of the top1 highscore, **love.graphics. printf("points: " .. math.floor(game.points), love.graphics.newFont(24), 0, love.graphics.getHeight() / 2, love.graphics.getWidth(), "center")**, **love.graphics.printf("name: " .. file_data.pontuacao[1].name .. " ".. "highscore: " .. high_score_value, love.graphics.newFont(24), 0, love.graphics.getHeight() / 1.5, love.graphics.getWidth(), "center")** and draws the mouse, **if game.state["ended"]** then draws the *ended_state* buttons , **buttons.ended_state.replay_game:draw(love.graphics.getWidth() / 2.3, 20, 45, 15)**, **buttons.ended_state.menu:draw(love.graphics.getWidth() / 2.3, 80, 45, 15)** and **buttons.ended_state.exit_game:draw(love.graphics.getWidth() / 2.3, 140, 45, 15)**, just below the last button through a loop from 1 to **#file_data.pontuacao**, writes **love.graphics.printf(i .. "° " .. file_data.pontuacao[i].name .. alignment .. file_data.pontuacao[i].high_score .. " points", love.graphics.newFont(24), 0, love.graphics.getHeight() / (2.5 - (0.3 * i)), love.graphics.getWidth(), "center")**(where alignment and a variable that stores 10 spaces - the size of the name, **local alignment = string.rep(" ", 10 - #file_data.pontuacao[i].name)**, for an aesthetic distance from the name to the equivalent punctuation , standard for names with 6 characters or less) and then draws the cheese with a height 2x smaller, along with the total amount of cheese on the account and the mouse, **if game.state["paused"]** draws the same of _running_, with addition of *paused_state* buttons, **buttons.paused_state.resume_game:draw(love.graphics.getWidth() / 2.3, 50, 45, 15)**, **buttons.paused_state.replay_game:draw (love.graphics.getWidth() / 2.3, 110, 45, 15)**, **buttons.paused_state.menu:draw(love.graphics.getWidth() / 2.3, 170, 45, 15)** and **buttons.paused_state.exit_game:draw(love.graphics.getWidth() / 2.3, 230, 45, 15)**, along with a condition of **if game.high_score = high_score_value** then writes to the right side of the screen the score of the current run, but otherwise it writes the highscore of the top1, and finally the mouse, after all it is just not designed for running, because it does not have buttons and would interfere with the "gameplay".
##### Conclusion:
The game has 7 visual states, intro, menu, settings, playing, paused, save score and end of game, where the intro presents the game, its creator and how to play, the menu and where you access the settings, starting the game and exit it, in addition to allowing you to watch the intro again, when playing the player's objective is to avoid the stones, while picking up cheese and trying to reach the highest score possible, to help the player he can jump using the space key on the keyboard or pause the game with the s key, while paused the player can either restart the game, or return to the menu, or close it or just return to playing where he left off, if the player is hit three times in a row by stones, he loses, having two options if he scored enough to enter the top3 he goes to where he saves the score, where he will be asked for his name, it is possible to save a name of up to 6 characters or save a nickname the player chooses and after saving or if the player does not reach top3 score he goes to the end of the game, where the top3 highscore for that account appears and he can either restart a game, or return to the menu, or exit the game.
##### Update:
The recommended screen size for the game is 1500 by 444, but that doesn't mean that on smaller screens like notebooks, the player is unable to play, so it was necessary to make it responsive so that when the game detects a smaller screen, it automatically adjusts the width to this screen, after all, 444 in height covers all current computer screens, so that this would be possible the following command lines were added to **love.load()**, **local width, height** stores the width and height values ​​of the desktop through **love.window.getDesktopDimensions()** and then **if width** is less than 1500 then **love.window.setMode(width, 444)** changes the size of the game window to the width of the desktop and keeps 444 in height.
#### Descrição(PT/BR):
##### Introdução:
Jogo _2D de estilo Corrida infinita_ feito na linguagem de **lUA**, com assistência da biblioteca **lUA ROCKS**, e em **LOVE**, além de usar um arquivo **JSON** para armazenamento de dados referente ao jogador. O projeto apresenta diversos arquivos **.lua**, devido à escolha do desenvolvedor<sup>Thales Tenorio de Medeiros</sup> de tratar os elementos do jogo _(personagem, inimigo, obstáculos e colecionáveis)_ como objetos criados a partir de functions, aonde cada um inicia com posicionamentos, tamanhos e velocidades padrões ao serem criados e isto permitira a **main.lua** quando importar seus arquivos mediante **require()** chamar suas functions e então criar o objeto dentro do jogo _(main.lua)_. Em suas function também apresenta sub-functions de ações como andar, pular e a de ser desenhado, ao qual também podem ser chamadas alterando as características inicias de tal objeto ou apenas desenhando na tela, _exemplo: **Player[1]:move**, aonde Player é uma lista que armazena o objeto **Steve()** de **Steve.lua** que possui uma function chamada **move()** que altera ou o eixo X ou o Y do **Player[1]**_, além dos 'objects'.lua estão presentes o **SFX.lua**, o **conf.lua** e o **save.json** aonde o _SFX_ é um arquivo para gerenciamento de áudio, permitindo adicionar, retirar áudios do jogo e também alterar o volume do mesmo, quanto ao _conf_ inclusive é um nome de arquivo padrão utilizado para o arquivo que ira manipular as propriedades da janela do jogo como titulo, ícone, tamanho de janela entre outros, em relação ao _save.json_ é um arquivo como antes dito para armazenamento, seu funcionamento é baseado na leitura e escrita simples de chaves e seus valores, aonde os dados devem ser importados para o código como uma lista ao qual poderá ser manipulada dentro do código, e então depois escrita no arquivo, o projeto apresenta também um arquivo chamado **Globals.lua** onde esta presente functions de utilidade tanto neste projeto quanto em outros, sendo uma de cálculo matemático e duas para atalhos de abrir e fechar o arquivo Json, e por fim vale falar sobre a escolha da música do jogo e dos sprites de todos os objetos e do plano de fundo, em relação à música a escolha foi feita na vontade de trazer a nostalgia dos jogos de Arcades antigos, quanto aos sprites são todos de autoria própria, em desenhos feitos na infância, houve unicamente a necessidade de completar os frames, o personagem principal e controlado pelo jogador se chama **Steve** sendo um rato, precisando desviar de obstáculos que são pedrinhas, enquanto coleta fatias de queijo e foge do inimigo chamado **Lunna** que é um cachorro.
##### Corpo do projeto:
###### Variaveis e funções adicionais:
Com a introdução completa irei explicar como **main.lua** funciona, quando cada um dos outros arquivos de objetos é chamado e a interação de _main_ com **SFX.lua**, **conf.lua** e **save.json**, o arquivo main começa importando através de **require()** todos os outros arquivos me permitindo no momento que achar melhor trabalhar com eles, importo o arquivo de dados em uma variavel e em seguida salvo em outra variavel o primeiro valor da chave highscore(top 1 pontuação), além de iniciar mais 3 variáveis, uma para armazenar uma string com valor inicial de **""**, chamada **name**, uma para armazenar um número **(time_init)**, sem valor inicial, outra **(time_space)** iniciada com o valor de _7.5_, e por última uma variavel que importa o **SFX()** importado de **sfx.lua**, depois uma sequência de **tables** iniciando com uma table representando a introdução do jogo **(intros)**, com cinco chaves e seus valores sendo elas, **title** aonde tem o nome do jogo **Chesse King**, **logo** aonde tem o caminho para uma imagem desenhada _(autoria própria)_ de um queijo completo com uma coroa, presente na pasta **Cheese_King**, **creator** armazenando o nome do criador e desenvolvedor do jogo ,**space** e **pause** as duas chaves com contesto igual aonde _space_ tem um texto informando que a tecla 'space' do teclado faz o jogador pular e _pause_ possui um texto tambem informando que a tecla 's' pausa o jogo, logo em seguida uma **table game** com chaves de tudo relacionada ao jogo em si, como uma **table state** com todos os estados do jogo **intro1, intro2, menu, running, configurations, paused, pontuacao e ended**, sendo inicialmente _intro1_ true e os outros false, na _table game_ tem tambem points que ira contar a pontuação corrente enquanto running, uma lista com as pontuações necessárias para haver mudanças no jogo, **level_change** {50, 200, 500, 1000, 3000}, uma variavel chamada **high_score** servira para um maior controle em relação ao **dt(a medida de tempo usada em love em relação aos 60 fps)** e comparar com as pontuações do nosso banco de dados **Json**, tem tambem 6 variáveis relacionadas a deixar sortido a posição tanto das pedras(obstáculos) como dos queijos(colecionáveis), são elas **randominit_r, randomend_r e randomrock** para as pedras **randominit_c, randomend_c, randomcheese** para os queijos, para os queijos temos ainda tambem uma lista vazia **cheeses** já que a intenção e fazer aparecer 5 queijos juntos, tem tambem a **cheese_space**, o espaço entre os queijos, com valor 6, tem a **cheese_icon** com o caminho de um desenho de fatia de queijo, presente na pasta **Cheese_King**, e a **cheese_round** que ira contar a quantia de queijo coletada em cada running separado, e por fim uma variavel importando o plano de fundo com parâmetro 0, **Background(0)** o plano de fundo ira iniciar no eixo x e y em 0, a próxima table é a **buttons** com uma lista vazia para cada state de game que tera pelo menos um botão, depois tem a table **mouse** que tem duas variáveis **mouse_x e mouse_y**, além da function **Mouse()** importada de **mouse.lua**, e então temos as tables dos protagonistas do jogo **player** e **enemy** ambas importam seus objetos respectivos, _player_ importa o **Steve()** e o _enemy_ a **Lunna()** ambos possuem uma table chamada **animation** onde tem **idle** se este parado ou não ambos começam em true, **frame** sprite atual ambos começam em 1, **max_frame** quantia máxima de sprite, _player_ tem 8 e _enemy_ 4 and **timer** sendo o contador de tempo ambos iniciam em 0.1, _player_ possui mais dois timer **jump_timer** e **hit_timer** sendo os contadores de tempo das chaves **jump** e **hit** que começam como false, já _enemy_ possui tambem uma chave a mais chamada **callback** que começa com 0, e para termina o programa inicia 3 listas vazias **background_run**, **stone** e **coletavel** que iram armazenar o fundo que se move, os obstáculos e os colecionáveis respectivamente. Ainda antes de iniciar o **love.load**, **update** ou **draw** existem algumas functions de suporte em _main_ são elas **changeGameState(state)** que permite mudar o **game.state**(chave state da table game) para a que foi passada, tornando true a entre parenteses e false todas outras, tem tambem a **startNewGame()** que reseta e prontifica todos os parâmetros de contagem para um novo jogo(running), sendo eles a variavel _name_ para "" novamente, **enemy.callback** para 0, esvazia novamente as tables _stone_, _coletavel_, _background_run_ e _game.cheeses_, diminui **game.difficult** para 1 novamente, **game.level_change[1]** para 50 novamente, chama a função _changeGameState("running")_ para mudar o estado de jogo para rodando, adiciona nas tabelas *background_run*, _stone_ e _coletavel_ um item respectivo a elas, o background por que é necessário, já a fatia de queijo e a pedrinha por motivos de teste de funcionamento, deixa **game.cheese_space** em 6 novamente, chama a função reset em _Steve()_ com **player[1]:reset()**, que reseta tanto sua localização x/y como a localização de sua hitbox, ambas para a localização inicial, esta função é principalmente pelo eixo y que varia quando o personagem é solicitado para pular, então ao reiniciar o jogo enquanto o personagem pulava, não haverá bugs, _startNewGame()_ reseta tambem as outras chaves de _player_ e _enemy_ **player.animation.jump** e **player.animation.hit** para false, todos **timers**(timer, jump_timer, hit_timer) de player e enemy para 0.1,  **player.animation.frame** e **enemy.animation_e.frame** para 1, atualiza a variavel que armazenava a pontuação top1 **high_score_value** com **file_data.pontuacao[1].high_score** sendo o primeiro valor da chave *high_score* de **pontuacao** de *file_data* que como dito antes é a table que armazena os dados do arquivo _Json_, diferente de _Steve()_, _Lunna()_ não possui hitbox, então o reset dele em _starNewGame()_ é mais direto com **enemy[1].x** para -320, e por fim as últimas alterações são na table _game_, **game.points** valor 0 para contar os pontos de uma nova run, *game.cheese_round* e *game.high_score* para 0 tambem, inicia **game.randominit_r** e **game.randominit_c** em 10, já **game.randomend_r** em *game.level_change[1]*(50) e  **game.randomend_c** em *game.level_change[2]*(200) e por fim **game.randomrock** com valor de **math.random(game.randominit_r, game.randomend_r)**(valor aleatório entre 10 e 50) e **game.randomcheese** com valor **math.random(game.randominit_c, game.randomend_c)**(valor aleatório entre 10 e 200), lembrando como são 5 queijos tem um loop de 1 a 5(repete cinco vezes) com **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)))**(apos o primeiro número ser escolhido, digamos que 180, ao ser inserido na tabela *game_cheeses* o primeiro sera 180 mais 6 vezes (1 menos 1), e assim por diante, preservando o primeiro número como o selecionado 180 e o restante mais 6 vezes(2 - 1), vezes(3 - 1), vezes(4 - 1), vezes(5 - 1)), isto é tudo de _startNewGame()_, outra função assistente é a **save()** nela sera inserido na tabela **file_data.pontuacao** tanto a variavel _nome_ e *game.high_score* logo apos tem uma função de tabela padronizada de lua **table.sort(file_data.pontuacao, function(a, b) return a.high_score  b.high_score end)** que permite organizar a tabela, a cada dois valores se o primeiro maior que o segundo, retorna o primeiro se não retorna o segundo e quem restou forma par com o próximo, assim organizando em ordem decrescente, apos a organização verifica se o tamanho da tabela é de 4, se for apaga os dados de posição 4 na tabela, assim permanecendo nos top3 sempre, e por fim salva em **file_data.queijo** a soma do próprio valor mais **game.cheese_round** que é a quantia de queijos da última run, depois disto escreve toda table **file_data** no arquivo_Json_ com **write("save", file_data)** e então **changeGameState("ended")**, a próxima função assistente chamada **credit()** é bem básica, ela apenas armazena em *time_init* o tempo atual, **love.timer.getTime**, e **changeGameState("intro1")**, e por fim uma função disponível por _LOVE_ para ações do mouse, **love.mousepressed(x, y, button, istouch, presses)**, para evitar perda de tempo verificando enquanto _game.state["running"]_, **if not game.state["running"]**, e então caso não, a partir da condição **button == 1** se houve click do botão esquerdo do mouse(primário), ele ira verificar se esta em _menu_, _configurations_, _paused_, _pontuacao_ ou _ended_ e então a partir de um loop ira verificar o checkPressed() de cada botão na lista correspondente ao state, **if game.state["menu"]** então **for index in pairs(buttons.menu_state)** verifica **buttons.menu_state[index]:checkPressed(x, y, mouse[1].radius)**, sendo x e y as localizações do mouse já oferecida pela função e _mouse[1].radius_ a hitbox do mouse, já que ele possui uma camuflagem de uma fatia de queijo em forma de cursor, por escolha estética, isso é tudo sobre as funções de assistência em _main_, mas antes de ir para **love.load()**, irei explicar como a function **button:checkPressed()** funciona, **checkPressed = function(self, mouse_x, mouse_y, mouse_radius)**, como visto antes *mouse_x* equivale ao x do mouse, *mouse_y* ao y do mouse e *mouse_radius* a _mouse[1].radius_ que é a hitbox do cursor, recebendo estes parâmetros ele é capaz de calcular atraves de uma fórmula matemática tambem presente em _Globals.lua_ só que modificada, já que a de _Globals_ calcula o encontro de duas hitbox circulares **calculateDistance(x1, y1, x2, y2)**, **dist_x = (x2 - x1) ^ 2**, **dist_y = (y2 - y1) ^ 2** e retornando **math.sqrt(dist_x + dist_y)**, e a de _Button_ calcula entre uma circular, hitbox do mouse, e uma retangular o próprio botão em si, usando para a largura, **se (mouse_x + (mouse_radius * 3) = self.button_x)** e **(mouse_x - mouse_radius = self.button_y)** e **(mouse_y - mouse_radius <= self.button_y + self.height)** se ambos forem correto a ponta da fatia de queijo que funciona de cursor esta em cima do botão, e junto ao click como dito antes, então a função atrelada ao botão ira funcionar, mas caso o botão não tenha função o botão não realizará nada. 
###### Love.load:
Ao término das funções esta o corpo do arquivo _main.lua_ em **LOVE**, **load()** sendo o menor dos três, trabalha com as atualizações estáticas e que devem ser iniciadas ao executar o jogo, sendo elas a criação dos botões e adição a suas respectivas listas de acordo com o state do jogo que irá aparecer(**buttons.menu_state.play_game = Button("play game", startNewGame, nil)**, onde será criado um botão na lista de botões **menu_state** com nome **play_game**, o botão por sua vez sendo uma função em **Button.lua** recebe três parâmetros, **function Button (text, func, func_param)**, seu texto, a função que ira realizar no _checkPressed()_ e caso tenha algum parâmetro para esta função o recebe tambem, sendo assim o botão *play_game* do menu do jogo, tem escrito play game e ao ser clicado ira iniciar um novo jogo através de _startNewGame()_), ao total são quatro botões para o **menu_state**, sendo eles **play game**, **settings** que _changeGameState_ para "configutations", **credits** que recebi _credit()_ e **exit game** que recebi **love.event.quit** uma função de _LOVE_ que para de a atual execução, tem também três botões de **pontuacao_state** sendo **name:** sem função, um botão com a **variavel string _nome_** sem função tambem, ambos são botões por escolha estética e o último botão é o de **confirm** iniciado sem função, mas que ganha uma em **love.update()**, **ended_state** possui três botões também sendo **replay game** com _starNewGame_, **menu** com _chageGameState()_ para "menu" e **exit game** também com mesmo atributos do com o mesmo nome em _menu_, em **paused_state** temos quatro botões, **resume** que _changeGameState_ para "running", **replay game**, **menu** e **exit** iguais aos outros botões de mesmo nome, apenas em outro state, e por fim os botões de **configurations_state** que são, **play_Stop_audio**, inicialmente aqui com nada escrito e sem funções, **Audio:** outro botão apenas estético, uma sequência de botões com texto **1 á 5**, todos com **changeVolume** com parâmetros _0.1_, _0.2_, _0.3_, _0.4_ e _0.5_ respectivamente, e o último botão sendo o **back** com _changeGameState_ para "menu", outras alterações em _load_ são deixar o cursor original invisível com **love.mouse.setVisible(false)** e adicionar o tempo inicial da execução, já que existe a intro do jogo, em *time_init* com **love.timer.getTime()**.
###### Love.update:
Em seguida temos o **love.update(dt)** como a segunda função base de _LOVE_, responsável pelas atualizações com o decorrer do tempo de execução, usando como parâmetro o **dt(delta time)**, que seria a representação de frames por segundo, mas devido aos processadores atuais o valor é representado mais ou menos por 0,013, para que a skin do mouse sempre esteja aonde ele estiver a cada segundo, **mouse.mouse_x, mouse.mouse_y = love.mouse.getPosition()** independente do _state_, como visto o jogo tem duas teclas de comando e uma terceira para escrita em _pontuacao_(backspace), para um maior controle, duas delas só funcionam ao soltar a tecla, usando a função **love.keyreleased(key)** aonde key sera a tecla, **se key == "space" and player.animation.jump == false and player.animation.hit == false and game.state["running"]**, ou seja, para pular e necessário soltar a tecla quando o personagem não estiver no meio de um pulo e nem atingido e obviamente o jogo estiver em _running_, então **player.animation.frame = 1**(reseta frame já que são compartilhados de andar e pular), **player.animation.idle = true** e **player.animation.jump = true**(indicar que é um pulo e não andar) e a segunda tecla **se key == "backspace" and game.state["pontuacao"]** quando a tecla backspace conhecida para apagar textos for solta enquanto o jogo estiver em _pontuacao_, então **nome = string.sub(nome, 1, -2)**(a string _nome_ através do **string.sub** que permite manipular uma string, recortando uma nova string de outra, uma string normal vai de 1 a -1, ao colocar 1 a -2 a nova string tera todos os caracteres menos o último e ao salvar em _nome_ sobrescreve a alteração dando sensação que se apagou o último digito), posterior a estas alterações, as próximas são divididas em _states_, **se game.state["intro1"]** então uma variavel chamada **time_count** ira guardar o tempo com **love.timer.getTime()** e devido a ser no update isso ira acontecer a cada segundo se em algum momento **time_count - time_init** for maior ou igual a *time_space*(7.5 segundos) então primeiramente **time_init = time_count** e **changeGameState("intro2")**, depois disso vem **se game.state["intro2"]** então novamente *time_count* ira guardar o tempo a cada segundo e **se time_count - time_init** for maior ou igual que *time_space* de novo então desta vez **changeGameState("menu")**, mudar das intros ate o menu depende apenas do tempo, depois sera pelos botões ou a derrota do jogador em "running", portanto o próximo é **se game.state["running"]** então começa indicando que tanto o jogador quanto o inimigo está andando com **player.animation.idle = false** e **enemy.animation_e.idle = false**, a próxima atualização por segundo sem condição além do state "running", é a contagem de pontos **game.points = game.points + (dt * 8)** o valor de dt * 8 é o mais perto de 1 por segundo possível, então este calculo faz com que _game.points_ aumente em 1 a cada segundo de "running" que se passe, achei importante que a próxima condição fosse a de derrota do jogador, que é **se enemy[1]:kill()**(a function **kill()** presente em _Lunna()_, devido ao inimigo não possuir hitbox apenas retorna verdadeiro **se self.x == -120** e falso se não) então ira verificar **se game.high_score** maior que **high_score_value**(primeiro lugar nos Json) ou maior que **file_data.pontuacao[2].high_score** ou que **file_data.pontuacao[3].high_score**(segundo e terceiro lugares), mas antes de pergunta sobre o segundo e o terceiro **#file_data.pontuacao** menor que 3(caso o tamanho do placar ainda for menor que 3), todas estas opções **changeGameState("pontuacao")**, mas caso tenha três high_score e todos são maiores que o atual então **changeGameState("ended")**, além de salvar a quantia de queijos da atual "running" no Json com **file_data.queijo = file_data.queijo + game.cheese_round**, **write("save", file_data)** e novamente importa os dados por questão de segurança **file_data = read("save")** e por fim caso _kill_ retorne falso, **enemy[1]:move(player.animation.hit, dt, enemy.callback)**(a function move em _Lunna_ funciona baseado em dois parâmetros internos da localização de x, e influência de hit do jogador, dt e callback, aonde **se not hit** então ele fara duas coisas distintas, **se self.x** maior que -660(limite de recuo do inimigo) e **cb == 0** então **self.x = self.x - dt * 200**[se move da direita para esquerda sumindo eventualmente da tela], agora se principalmente **cb** maior que 0 então **self.x = self.x**[permanece no lugar], mas caso haja o _hit do jogador então **se self.x** menor que -120[limite de avanço, lembrando que -120 é _kill_] então **self.x = self.x + dt * 200** o inimigo avança, reaparecendo na tela), em seguida temos a verificação de todos os objetos das listas *background_run*, _coletavel_ e _stone_ para fazer algumas alterações e principalmente acionar o _move_ de cada um, começando pelo mais simples, um loop de 1 ao **#stone**(tamanho da lista), **stone[l]:move(dt, player.animation.jump)**(lembrando que a dificuldade maxima e de 8, aonde a velocidade da pedra é **20 * level** se menor que 8 e se maior **20 * 8**, como o pulo no nível 1 é incapaz de passar a pedra, mas achei ser a velocidade ideal de começo então o _move_ tem duas opções **se pulo**(personagem pulou) e **self.lvl** menor que 2 então tanto a pedra em si **self.x** como sua hitbox **self.circle_x** serão iguais ao mesmo **- self.speed * (dt * 25) - self.lvl** e caso não esteja pulando no nível 1, ou seja, maior ou igual ao nível 2 pulando ou não então ambos serão diminuídos por **- self.speed * (dt * 10) - self.lvl**, tanto a primeira como a segunda opção a pedra ira aparecer devido aos parâmetros do próprio objeto no final da tela a direita e ira se mover dependendo destes **ifs** de _move_ e da **dificuldade do jogo** para extrema esquerda da tela), para lista _coletavel_ é basicamente o mesmo em _move_ de _Queijo_, e ao usar de 1 ao **#coletavel** faça **coletavel[i]:move(dt, player.animation.jump)**, a única diferença e que o queijo possui uma peculiaridade por opção visual, de **se calculateDistance(stone[j].circle_x, stone[j].circle_y, coletavel[i].circle_x, coletavel[i].circle_y)** menor ou igual que **coletavel[i].radius * 2** (hitbox do queijo e de alguma pedra presente na lista _stone_ estiverem sobrepostas) então tanto **coletavel[i].y** quanto o **coletavel[i].circle_y** iram diminuir de si mesmos - 10 como e um _if_ em _update_ ira acontecer ate não estarem mais sobrepostos, resumindo o queijo que estiver aparecido no mesmo lugar da pedra sera ejetado para cima dela, em uma velocidade imperceptível aos olhos humanos, e por fim a lista de *background_run*, ira verificar de 1 ao seu tamanho, inicialmente cria e armazena em **background_value** **CalculateComplement(background_run[a].totalwidth, background_run[a].width)** a função de _globals.lua_ que serve para saber o resto do background que esta fora de tela, com isso **se background_run[a].x** maior que **background_value**, e menor que **background_value + background_run[a].speed * (dt * 10)**(o valor fora de tela mais a velocidade do background em uma unidade, para pegar o menor valor possível em que o background esteja sem nada fora de tela levando em conta a velocidade de seu movimento independente da dificuldade) então **table_insert(background_run, BackGround(love.graphics.getWidth() - 1))**(insere na lista, um novo background, no fim da tela) e enquanto o personagem não for atingido então **background_run[a]:move(dt)**, o **dt** de _update_ excelente para trabalhar com frames, e atualizações sequenciais ou rápidas, mas para atualizações singulares acaba apresentando problema, minha solução foi adicionar estas atualizações singulares dentre de outra atualização recorrente, no caso **se math.floor(game.points)** maior que **game.high_score** então **game.high_score = math.floor(game.points)**, atualização recorrente para o highscore da atual "running", mas quando a condição é preenchida não realiza mais nada ate o que estiver dentro estar concluído, ao adicionar atualizações singulares dentro dela, permite que estás só ativem uma vez, o que é o exemplo das alterações no jogo rodando, começando com **se math.floor(game.points) % game.level_change[2] == 0**(o símbolo % serve para achar o resto de uma divisão, logo todos os múltiplos de *level.change[2]*) e, além disso, também menor que **game.level_change[4]** então diminui **game.level_change[1]** em 5, **game.cheese_space** em 1 e aumenta **game.difficult** em 1, e para prevenir bugs faz o mesmo sendo que com os objetos ainda existentes nas listas **game.cheeses**, **stone** e **coletavel**, já **se math.floor(game.points)** maior que **game.level_change[4]**, menor que **game.level_change[5]** e **math.floor(game.points) % game.level_change[3] == 0** então a dificuldade aumenta em 1, **game.level_change[1]** diminui em 2 e **se game.difficult** menor que 8 então regula a dificuldade dos objetos das listas **stone** e **colecionavel**, e de última alteração "in game", **se math.floor(game.points)** maior que **game.level_change[5]** e **math.floor(game.points) % game.level_change[4] == 0** diminui **game.level_change[1]** em 1 com restrição, para deixar o jogo balanceado, para *game.level_change[1]* só pode diminuir ate 11, agora em relação à adição das pedras e queijos ambos verificam **se math.floor(game.points)** é igual ao seu _game.random_ correspondente e então armazena **math.floor(game.points)** em _game.randominit_ e para pedra **game.randomend_r = game.randominit_r + game.level_change[1]**, para queijos **game.randomend_c = game.randominit_c + game.level_change[2]**, calcula novos valores _randons_, mas com uma condição de para as pedras **game.randomrock - game.randominit_r** seja maior que 10 através de um loop **While** para impedir que a nova pedra tenha uma distância muito pequena em relação a anterior, e para o queijo o mesmo sendo que em seu _while_ **game.randomcheese - game.randominit_c** deve ser maior que 50, apos um valor _random_ satisfatório, e quanto a função correspondente as pedras adicionam uma para a lista _stone_, para os queijos, através de um loop de 1 a 5 faz, **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)))** e para termina o que esta na verificação de pontos, um loop para todos valores da lista de _game.cheeses_ **se math.floor(game.points)** for igual a **game.cheeses[i]** então **table.insert(coletavel, Queijo(game.difficult))** e para manter a lista apenas com o necessário **table.remove(game.cheeses, game.cheeses[i])**, apos tudo isso temos outro tipo de verificação para o teclado, **se love.keyboard.isDown("s")**(quando a tecla for pressionada, no caso o "s") então muda o estado do jogo para "paused", depois uma verificação novamente em todos os objetos das listas _coletavel_ e _stone_ onde **se calculateDistance(player[1].circle_x, player[1].circle_y, objeto[i].circle_x, objeto[i].circle_y)** for menor que **objeto[i].radius * 2**(objeto pode ser ou stone ou coletavel, ele verifica se o hitbox do jogador se encontrou com o de uma pedra ou de um queijo) e para os coletáveis **and not player.animation.hit** (escolha visual o personagem não pega queijos caso estiver atingido), para as pedras, ela e removida da lista, e o frame do jogador e resetado para 1, e seu estado é mudado para **hit = true** e **enemy.callback = 1**(atingido atualmente e o inimigo, após se mover ira ficar parado), para os queijos, eles serão tambem removidos de sua lista, mas **game.cheese_round = game.cheese_round + 1**, em ambas verificações tambem possui a condição de caso o objeto saia da tela **se objeto[i].x** menor que **0 - objeto[i].radius * 3**(sendo objeto ou coletavel ou stone), ambos serão deletados de sua lista respectiva, mas em pedras, **enemy.callback = 0**(ao pular uma pedra o steve foge de lunna), e para finalizar o que acontece em "running", temos os alteradores de frames para cada animação com seu tempo baseado em _dt_, aonde para cada **player.animation.** e **enemy.animation_e.idle** o timer de cada um destes estados de animação e somado + dt, como exemplo **enemy.animation_e.timer = enemy.animation_e.timer + dt**, quando este timer chegar em 0.4 e 0.25 para _enemy_(animação mais frenética), o _timer_ é resetado e a quantia de frames aumenta em 1, caso para player em _hit_ chegar ao *max_frames*, o frame reseta para 7, hit para false e idle para false, já em _jump_ precisa chegar em *max_frames/2*, reseta frame pára 6, jump false e idle false, e na _animation_ de _idle_ só reseta os frames para 4(1 a 3, são frames de início de corrida, o loop de corrida é entre 4 a 8), para *enemy.animation_e.max_frames* ele volta para o frame 1, as próximas atualizações são em **se game.state["pontuacao"]** aonde fica a função de _LOVE_ responsável para pegar o input do jogador na hora de escrever seu nome, **love.textinput(t)**, **se #nome** menor que 6 **and game.state["pontuacao"]**(como input é uma função que após acionada fica ativa permanente, e preciso reafirma que só deve funcionar quando estiver em "pontuacao" e por questão de logística o nome deve ser menor que 6, mas aceita números, letras e símbolos) então **nome = nome .. t**(ira adicionar a string nome, o input do jogador), atualiza os botões **buttons.pontuacao_state.nameinput = Button(nome, nil, nil)** para exibir em tempo real este nome, e **se #nome  0**(se o jogador não digitar nada, não ira acionar uma função para o botão de confirm) então **buttons.pontuacao_state.confirm = Button("confirm", save, nil)**, se não o botão tera o mesmo texto, mas não realizara nenhuma ação, em **game.state["configurations"]**, temos a atualização do botão de música onde **se not audio:playing_BGM()**(não tiver música em execução) então **buttons.configurations_state.play_Stop_audio = Button("Play", changeAudio, nil)**(o botão ira aciona-la) senão **buttons.configurations_state.play_Stop_audio = Button("Stop", changeAudio, nil)**(ira para-la) e antes de **love.draw**, **se game.state["paused"]** ou **game.state["ended"]** ou **game.state["pontuacao"]** então para de atualizar a pontuação, o highscore e os idle do player e do enemy ficão true, parando a movimentação de ambos.
###### Love.draw:
Por último temos o **love.draw()**, afinal já criamos variáveis e funções, carregamos botões, atualizamos estas variáveis, funções e botões de acordo com nossa vontade, mas tudo isso esta acontecendo fora dos olhos do jogador, _draw_ é o responsável pelo que realmente ira aparecer na tela visualmente, novamente dividiremos pelo state do jogo, mas antes **game.background:draw()**(fundo estático estará em todos states), **love.graphics.printf("FPS:." .. love.timer.getFPS(), love.graphics.newFont(16), 10, 10, love.graphics.getWidth())**(a função _LOVE_, **getFPS** permite ver o fps do aplicativo love que esta sendo executado, em uma fonte tamanho 16, com eixo x = 10 e y = 10, independente do state), e então **se game.state["intro1"]** então ira desenhar **love.graphics.draw(intros.logo, love.graphics.getWidth() / 3, -100)**(**graphics.draw** serve para desenhar uma imagem, no caso a imagem de _intros.logo_, eixo x=**getWidth()** serve para pegar o tamanho em largura da janela do aplicativo, /3, devido à propriedade da imagem este valor ira fazer com que a imagem fique centralizada horizontalmente, eixo y = 100) e em baixo da logo do jogo tem o nome com **love.graphics.printf(intros.title, love.graphics.newFont(50), love.graphics.getWidth() / 2.7, 250, love.graphics.getWidth())**(após eixo x e y, e possível colocar um parâmetro de controle no caso **love.graphics.getWidth()**, serve para centralizar textos) e por fim o mouse, **mouse[1]:draw(mouse.mouse_x, mouse.mouse_y)**, em **se game.state["intro2"]** então **love.graphics.setColor(0, 0, 0)**(muda a cor de texto, e desenhos que usem formas, além de acrescentar uma camada visual desta cor sobre imagens, usa o esquema RGB, no caso a cor preta) com esta cor **love.graphics.printf("creator:     " .. intros.creator, love.graphics.newFont(30), love.graphics.getWidth() / 3.5, 50, love.graphics.getWidth())**(escreve o nome do criador indicado que este é o criador juntando uma string com **intros.creator** que tambem possui uma string), **love.graphics.printf("In Game", love.graphics.newFont(30), love.graphics.getWidth() / 2.5, 110, love.graphics.getWidth())**(logo abaixo, informação visual pro jogador), em seguida digita através de **printf** as informações para jogar, **.graphics.printf(intros.space, love.graphics.newFont(30), love.graphics.getWidth() / 3.8, 200, love.graphics.getWidth())**(escreve a informação de **intros.space**), **love.graphics.printf(intros.pause, love.graphics.newFont(30), love.graphics.getWidth() / 1.8, 200, love.graphics.getWidth())**(as informações de **intros.pause**), retorna a cor para branco(padrão), **love.graphics.setColor(1, 1, 1)** e desenha o mouse novamente, **se game.state["running"]**, ira desenhar todos os planos de fundos de *background_run* usando **background_run[l]:draw()**(aonde em um loop de 1 a **self.var** aonde _self.var_ **math.ceil(_totalwidth / _width)**), então **love.graphics.draw(self.sprite, self.x + (self.width * (i - 1)), self.y)**(ele ira desenhar sprites ate a tela está coberta pelos planos de fundo, são necessários 2, lembrando que o eixo x é dado em update, sendo 0 no estático e no inicial e fim da janela para os próximos, e o eixo y é sempre 0), desenha a pontuação **love.graphics.printf(math.floor(game.points), love.graphics.newFont(24), 0, 10, love.graphics.getWidth(), "center")** no topo da tela centralizado, através dos dois últimos parâmetros, em seguida **love.graphics.push()** serve para salvar alterações mais dinâmicas de *graphics*, no caso esta salvando as configurações padrões, e então **love.graphics.scale(0.5, 0.5)** (muda a escala de tudo duas vezes menor), **love.graphics.draw(game.cheese_icon, love.graphics.getWidth() * 1.7, -90)**(desenha a imagem de um queijo, para servir de contagem), e então usa **love.graphics.pop()** que serve para volta as configurações de_graphics_, para o _push()_ mais perto, desativando assim o _scale_, **love.graphics.printf(":" .. " " .. game.cheese_round, love.graphics.newFont(16), love.graphics.getWidth() - 120, 20, love.graphics.getWidth())**, escreve o valor de queijos da atual "run", depois do desenho do queijo e separado por ":", em seguida desenha os objetos das listas _coletavel_ e _stone_ com suas respectivas funções _draw()_, sendo o objeto e sua hitbox, no eixo x, fora de tela a direita e eixo y um pouco acima do fim da tela e então desenha o jogador e o inimigo, **player[1]:draw(player.animation.frame, player.animation.jump, game.state["paused"], player.animation.hit)**, **enemy[1]:draw(enemy.animation_e.frame)**(ambos recebe o frame coimo parâmetro, para saber o **quad** que deve ser usado, **NewQuad()** é uma função de _LOVE_ que permite dividir uma imagem em pedaços dela, dividindo a sprite temos os frames), já player recebe outros parâmetros por que enquanto _not idle_ usa **self.quads[frames]**, se _hit_ usa **self.sprite3**(sprite de hit só possui uma imagem), e se _jump_ usa **self.quads2[frames]**, em seguida temos **se game.state["menu"]** então desenha os botões de *menu_state*, **buttons.menu_state.play_game:draw(20, 40, 45, 15)**, **buttons.menu_state.settings:draw(20, 100, 45, 15)**, **buttons.menu_state.creditos:draw(20, 160, 45, 15)** e **buttons.menu_state.exit_game:draw(20, 220, 45, 15)**, sendo um abaixo do outro devido à alteração apenas no eixo y, e então desenha o queijo em escala 2x menor junto a quantia de queijos total da conta, e termina desenhando o mouse, **se game.state["configurations"]** desenha os botões de *configurations_state*, **buttons.configurations_state.play_Stop_audio:draw(20, 40, 45, 15)**, e então os botões de volume abaixo do play, mas um do lado do outro, **buttons.configurations_state.audio:draw(20, 100, 45, 15)**, **buttons.configurations_state.one:draw(120, 100, 45, 15)**, **buttons.configurations_state.two:draw(220, 100, 45, 15)**, **buttons.configurations_state.three:draw(320, 100, 45, 15)**, **buttons.configurations_state.four:draw(420, 100, 45, 15)** e **buttons.configurations_state.five:draw(520, 100, 45, 15)**, abaixo deles o botão para retorna pro menu **buttons.configurations_state.back:draw(20, 160, 45, 15)**, e por fim o mouse, **se game.state["pontuacao"]** então desenha todas pedras, queijos e o inimigo, como pontuação é o momento de derrota do player, ele não aparece por escolha estética, desenha os botões de *pontuacao_state*, **buttons.pontuacao_state.name:draw(love.graphics.getWidth() / 2.3, 80, 45, 15)**, **buttons.pontuacao_state.nameinput:draw(love.graphics.getWidth() / 2.0, 80, 45, 15)** e **buttons.pontuacao_state.confirm:draw(love.graphics.getWidth() / 2.3, 140, 45, 15)** e escreve a pontuação atual, junto a pontuação e nome do top1 highscore, **love.graphics.printf("points: " .. math.floor(game.points), love.graphics.newFont(24), 0, love.graphics.getHeight() / 2, love.graphics.getWidth(), "center")**, **love.graphics.printf("name: " .. file_data.pontuacao[1].name .. "  ".. "highscore: " .. high_score_value, love.graphics.newFont(24), 0, love.graphics.getHeight() / 1.5, love.graphics.getWidth(), "center")** e desenha o mouse, **se game.state["ended"]** então desenha os botões de *ended_state*, **buttons.ended_state.replay_game:draw(love.graphics.getWidth() / 2.3, 20, 45, 15)**, **buttons.ended_state.menu:draw(love.graphics.getWidth() / 2.3, 80, 45, 15)** e **buttons.ended_state.exit_game:draw(love.graphics.getWidth() / 2.3, 140, 45, 15)**, logo abaixo do último botão através de um loop de 1 a **#file_data.pontuacao**, escreve **love.graphics.printf(i .. "° " .. file_data.pontuacao[i].name .. alinhamento .. file_data.pontuacao[i].high_score .. " points", love.graphics.newFont(24), 0, love.graphics.getHeight() / (2.5 - (0.3 * i)), love.graphics.getWidth(), "center")**(aonde alinhamento e um variavel que armazena 10 espaço - o tamanho do nome, **local alinhamento = string.rep(" ", 10 - #file_data.pontuacao[i].name)**, para uma estética de distância do nome para a pontuação equivalente, de forma padrão para nomes com 6 caracteres ou menos) e então desenha o queijo de estatura 2x menor, junto a quantia de queijo total da conta e o mouse, **se game.state["paused"]** desenha o mesmo de _running_, com adição dos botões de *paused_state*, **buttons.paused_state.resume_game:draw(love.graphics.getWidth() / 2.3, 50, 45, 15)**, **buttons.paused_state.replay_game:draw(love.graphics.getWidth() / 2.3, 110, 45, 15)**, **buttons.paused_state.menu:draw(love.graphics.getWidth() / 2.3, 170, 45, 15)** e **buttons.paused_state.exit_game:draw(love.graphics.getWidth() / 2.3, 230, 45, 15)**, junto a uma condição de **se game.high_score = high_score_value** então escreve do lado direito da tela a pontuação da run atual, mas senão escreve o highscore do top1, e por fim o mouse, afinal ele só não é desenhado em running, por que não possui botões e iria atrapalhar a "gameplay".
##### Conclusão:
O jogo possui 7 estados visualmente, intro, menu, configurações, jogando, pausado, salvar pontuação e fim de jogo, aonde a intro apresenta o jogo, seu criador e como jogar, o menu e aonde acessa às configurações, a começar o jogo e sair dele, além de permitir assistir a intro novamente, quando estiver jogando o objetivo do jogador e desviar das pedras, enquanto pega queijos e tenta alcançar a maior pontuação possível, para auxiliar o jogador ele pode pular usando a tecla espaço do teclado ou pausar o jogo com a tecla s, enquanto pausado o jogador ou pode reiniciar o jogo, ou voltar ao menu, ou fecha-lo ou apenas volta a jogar de onde parou, caso o jogador seja atingido três vezes seguidas por pedras, ele perde, tendo duas opções se ele fez uma pontuação suficiente para entrar no top3 ele vai para onde salva a pontuação, onde sera perguntado seu nome, é possível salvar um nome de ate 6 caracteres ou salvar um apelido o jogador escolhe e após salva ou se o jogador não atingir pontuação top3 ele vai para o fim de jogo, onde aparece os top3 highscore daquela conta e ele pode ou reiniciar um jogo, ou voltar pro menu, ou sair do jogo. 
##### Atualização:
O tamanho de tela recomendado do jogo é de 1500 por 444, mas não quer dizer que em telas menores como notebook, o jogador seja impossibilitado de jogar, então foi necessário fazê-lo responsivo para quando o jogo detectar uma tela menor, ele ajuste automaticamente a largura a esta tela, afinal 444 de altura abrange todas as telas de computadores atuais, para que isto fosse possível adicionei as seguintes linhas de comando em **love.load()**, **local width, height** armazena os valores de largura e altura da área de trabalho por meio de **love.window.getDesktopDimensions()** e então **se width** menor que 1500 então **love.window.setMode(width, 444)** altera o tamanho da janela do jogo para a largura da área de trabalho e mantém 444 de altura.
