# PROJECT CHEESE KING
#### Video Demo:  <URL HERE>
#### Description:
Jogo _2D de estilo Corrida infinita_ feito na linguagem de **lUA**, com assistencia da biblioteca **lUA ROCKS**, e em **LOVE**, alem de usar um arquivo **JSON** para armazenamento de dados referente ao jogador. O projeto apresenta diversos arquivos **.lua**, devido a escolha do desenvolvedor<sup>Thales Tenorio de Medeiros</sup> de tratar os elementos do jogo _(pessonagem, inimigo, obstaculos e colecionaveis)_ como objetos criados apartir de functions, aonde cada um inicia com posicionamentos, tamanhos e velocidades padrões ao serem criados e isto permitira a **main.lua** quando importar seus arquivos atraves de **require()** chamar suas functions e entâo criar o objeto dentro do jogo _(main.lua)_. Em suas function tambem esta presente sub-functions de ações como andar, pular e a de ser desenhado, ao qual tambem podem ser chamadas alterando as caracteristicas inicias de tal objeto ou apenas desenhando na tela, _exemplo: **Player[1]:move**, aonde Player é uma lista que armazena o obejto **Steve()** de **Steve.lua** que possui uma function chamada **move()** que altera ou o eixo X ou o Y do **Player[1]**_, além dos 'objects'.lua estão presentes o **SFX.lua**, o **conf.lua** e o **save.json** aonde o _SFX_ é um arquivo para gerenciamento de audio, permitindo adicionar, retirar audios do jogo e tambem alterar o volume do mesmo, quanto ao _conf_ inclusive é um nome de arquivo padrão utilizado para o arquivo que ira manipular as propriedades da janela do jogo como titulo, icone, tamanho de janela entre outros, em relação ao _save.json_ é um arquivo como antes dito para armazenamento, seu funcionamento é baseado na leitura e escrita simples de chaves e seus valores, aonde os dados devem ser importados para o codigo como uma lista ao qual podera ser manipulada dentro do codigo, e entao depois escrita no arquivo, o projeto apresenta tambem um arquivo chamado **Globals.lua** onde esta presente functions de utilidade tanto neste projeto quanto em outros, sendo uma de calculo matematico e duas para atalhos de abrir e fechar o arquivo Json, e por fim vale falar sobre a escolha da musica do jogo e dos sprites de todos objetos e do plano de fundo, em relação a musica a escolha foi feita na vontade de trazer a nostalgia dos jogos de arcades antigos, quanto aos sprites são todos de autoria propria, em desenhos feitos na infancia, houve unicamente a necessidade de completar os frames, o personagem principal e controlado pelo jogador se chama **Steve** sendo um rato, precisando desviar de obstaculos que são pedrinhas, enquanto coleta fatias de queijo e foge do inimigo chamado **Lunna** que é um cachorro. 

Com a introdução completa irei explicar como **main.lua** funciona, quando cada um dos outros arquivos de objetos é chamado e a interação de _main_ com **SFX.lua**, **conf.lua** e **save.json**, o arquivo main começa importando atraves de **require()** todos os outros arquivos me permitindo no momento que achar melhor trabalhar com eles, importo o arquivo de dados em uma variavel e em sequida salvo em outra variavel o primeiro valor da chave highscore(top 1 pontuação), além de iniciar mais 3 variaveis, uma para armazenar uma string com valor inicial de **""**, chamada **name**, uma para armazenar um numero **(time_init)**, sem valor inicial, outra **(time_space)** iniciada com o valor de _7.5_, e por ultima uma variavel que importa o **SFX()** importado de **sfx.lua**, depois uma sequencia de **tables** iniciando com uma table representando a introdução do jogo **(intros)**, com cinco chaves e seus valores sendo elas, **title** aonde tem o nome do jogo **Chesse King**, **logo** aonde tem o caminho para uma imagem desenhada _(autoria propia)_ de um queijo completo com uma coroa, presente na pasta **Cheese_King**, **creator** armazenando o nome do criador e desenvolvedor do jogo ,**space** e **pause** as duas chaves com contesto igual aonde _space_ tem um texto informando que a tecla 'space' do teclado faz o jogador pular e _pause_ possui um texto tambem informando que a tecla 's' pausa o jogo, logo em sequida uma **table game** com chaves de tudo relacionada ao jogo em si, como uma **table state** com todos os estado do jogo **intro1, intro2, menu, running, configurations, paused, pontuacao e ended**, sendo inicialmente _intro1_ true e os outros false, na _table game_ tem tambem points que ira contar a pontuação corrente enquanto running, uma lista com as pontuações necessarias para haver mudanças no jogo, **level_change** {50, 200, 500, 1000, 3000}, uma variavel chamada **high_score** servira para um maior controle em relação ao **dt(a medida de tempo usada em love em relação aos 60 fps)** e comparar com as pontuações do nosso banco de dados **Json**, tem tambem 6 variaveis relacionadas a deixar sortido a posição tanto das pedras(obstaculos) como dos queijos(colecionaveis), são elas **randominit_r, randomend_r e randomrock** para as pedras **randominit_c, randomend_c, randomcheese** para os queijos, para os queijos temos ainda tambem uma lista vazia **cheeses** ja que a intenção e fazer aparecer 5 queijos juntos, tem tambem a **cheese_space**, o espaço entre os queijos, com valor 6, tem a **cheese_icon** com o caminho de um desenho de fatia de queijo, presente na pasta **Cheese_King**, e a **cheese_round** que ira contar a quantia de queijo coletada em cada running separado, e por fim uma variavel importando o plano de fundo com parametro 0, **Background(0)** o plano de fundo ira iniciar no eixo x e y em 0, a proxima table é a **buttons** com uma lista vazia para cada state de game que tera pelo menos um botão, depois tem a table **mouse** que tem duas variaveis **mouse_x e mouse_y**, alem da function **Mouse()** importada de **mouse.lua**, e então temos as tables dos protagonistas do jogo **player** e **enemy** ambas importam seus objetos respectivos, _player_ importa o **Steve()** e o _enemy_ a **Lunna()** ambos possuem uma table chamada **animation** onde tem **idle** se esta parado ou não ambos começam em true, **frame** sprite atual ambos começam em 1, **max_frame** quantia maxima de sprite, _player_ tem 8 e _enemy_ 4 and **timer** que é o contador de tempo ambos iniciam em 0.1, _player_ possui mais dois timer **jump_timer** e **hit_timer** que são os contadores de tempo das chaves **jump** e **hit** que começam como false, ja _enemy_ possui tambem uma chave a mais chamada **callback** que começa com 0, e para termina o programa inicia 3 listas vazias **background_run**, **stone** e **coletavel** que iram armazenar o fundo que se move, os obstaculos e os colecionaveis respectivamente. Ainda antes de iniciar o **love.load**, **update** ou **draw** existem algumas functions de suporte em _main_ são elas **changeGameState(state)** que permite mudar o **game.state**(chave state da table game) para a que foi passada, tornando true a entre parenteses e false todas outras, tem tambem a **startNewGame()** que reseta e prontifica todos parametros de contagem para um novo jogo(running), sendo eles a variavel _name_ para "" novamente, **enemy.callback** para 0, exvazia novamente as tables _stone_, _coletavel_, _background_run_ e _game.cheeses_, diminui **game.difficult** para 1 novamente, **game.level_change[1]** para 50 novamente, chama a função _changeGameState("running")_ para mudar o estado de jogo para rodando, adiciona nas tabelas *background_run*, _stone_ e _coletavel_ um item respectivo a elas, o background por que é nescessario ja a fatia de queijo e a pedrinha por motivos de teste de funcionamento, deixa **game.cheese_space** em 6 novamente, chama a função reset em _Steve()_ com **player[1]:reset()**, que reseta tanto sua localização x/y como a localização de sua hitbox,ambas para a localização inicial, esta função é principalmente pelo eixo y que varia quando o personagem é solicitado para pular, então ao reiniciar o jogo enquanto o personagem pulava, não havera bugs, _startNewGame()_ reseta tambem as outras chaves de _player_ e _enemy_ **player.animation.jump** e **player.animation.hit** para false, todos **timers**(timer, jump_timer, hit_timer) de player e enemy para 0.1,  **player.animation.frame** e **enemy.animation_e.frame** para 1, atualiza a variavel que armazernava a pontuação top1 **high_score_value** com **file_data.pontuacao[1].high_score** que é o primeiro valor da chave *high_score* de **pontuacao** de *file_data* que como dito antes é a table que armazena os dados do arquivo _Json_, diferente de _Steve()_, _Lunna()_ não possui hitbox, então o reset dele em _starNewGame()_ é mais direto com **enemy[1].x** para -320, e por fim as ultimas alterações são na table _game_, **game.points** valor 0 para contar os pontos de uma nova run, *game.cheese_round* e *game.high_score* para 0 tambem, inicia **game.randominit_r** e **game.randominit_c** em 10, ja **game.randomend_r** em *game.level_change[1]*(50) e  **game.randomend_c** em *game.level_change[2]*(200) e por fim **game.randomrock** com valor de **math.random(game.randominit_r, game.randomend_r)**(valor aleatorio entre 10 e 50) e **game.randomcheese** com valor **math.random(game.randominit_c, game.randomend_c)**(valor aleatorio entre 10 e 200), lembrando como são 5 queijos tem um loop de 1 a 5(repete cinco vezes) com **table.insert(game.cheeses, game.randomcheese + (game.cheese_space * (i - 1)))**(apos o primeiro numero ser escolhido, digamos que 180, ao ser inserido na tabela *game_cheeses* o primeiro sera 180 mais 6 vezes (1 menos 1), e assim por diante, presevando o primeiro numero como o selecionado 180 e o restante mais 6 vezes(2 - 1), vezes(3 - 1), vezes(4 - 1), vezes(5 - 1)),isto é tudo de _startNewGame()_, outra função assitente é a **save()** nela sera inserido na tabela **file_data.pontuacao** tanto a variavel _nome_ e *game.high_score* logo apos tem uma função de tabela padronizada de lua **table.sort(file_data.pontuacao, function(a, b) return a.high_score > b.high_score end)** que permite organizar a tabela, de dois em dois valores se o primeiro maior que o segundo, retorna o primeiro se não retorna o segundo e quem restou forma par com o proximo, assim organizando em ordem decrescente, apos a organização verifica se o tamanho da tabela é de 4, se for apaga os dados de posição 4 na tabela, assim permanecendo nos top3 sempre, e por fim salva em **file_data.queijo** a soma do proprio valor mais **game.cheese_round** que é a quantia de queijos da ultima run, depois disto escreve toda table **file_data** no arquivo_Json_ com **write("save", file_data)** e então **changeGameState("ended")**, a proxima função assistente chamada **credit()** é bem basica, ela apenas armazena em *time_init* o tempo atual, **love.timer.getTime()**, e **changeGameState("intro1")**, e por fim uma função disponivel por _LOVE_ para ações do mouse, **love.mousepressed(x, y, button, istouch, presses)**, para evitar perda de tempo verificando enquanto _game.state["running"]_, **if not game.state["running"]**, e então caso não, apartir da condição **button == 1** se houve click do botão esquerdo do mouse(primario), ele ira verificar se esta em _menu_, _configurations_, _paused_, _pontuacao_ ou _ended_ e então apartir de um loop ira verificar o checkPressed() de cada botão na lista correspodente ao state, **if game.state["menu"]** então **for index in pairs(buttons.menu_state)** verifica **buttons.menu_state[index]:checkPressed(x, y, mouse[1].radius)**, sendo x e y as localizações do mouse ja oferecida pela função e _mouse[1].radius_ a hitbox do mouse, ja que ele possui uma camuflagem de uma fatia de queijo em forma de cursor, por escolha estetica, isso é tudo sobre as funções de assistencia em _main_, mas antes de ir para **love.load()**, irei explicar como a function **button:checkPressed()** funciona, **checkPressed = function(self, mouse_x, mouse_y, mouse_radius)**, como visto antes *mouse_x* equivale ao x do mouse, *mouse_y* ao y do mouse e *mouse_radius* a _mouse[1].radius_ que é a hitbox do cursor, recebendo estes parametros ele é capaz de calcular atraves de umna formula matematica tambem presente em _Globals.lua_ so que modificada, ja que a de _Globals_ calcula o encontro de duas hitbox circulares **calculateDistance(x1, y1, x2, y2)**, **dist_x = (x2 - x1) ^ 2**, **dist_y = (y2 - y1) ^ 2** e retornando **math.sqrt(dist_x + dist_y)**, e a de _Button_ calcula entre uma circular, hitbox do mouse, e uma rectangular o proprio botão em si, usando para a largura, **se (mouse_x + (mouse_radius * 3) >= self.button_x)** e **(mouse_x - mouse_radius <= self.button_x + self.width)**, e para a altura **se (mouse_y + mouse_radius >= self.button_y)** e **(mouse_y - mouse_radius <= self.button_y + self.height)** se ambos forem correto o ponta da fatia de queijo que funciona de cursor esta encima do botão, e junto ao click como dito antes, então a função atrelada ao botão ira funcionar, mas caso o botão não tenha função o botão não realizará nada. Ao termino das funções esta o corpo do arquivo _main.lua_ em **LOVE**, **load()** que é o menor dos tres, trabalha com as atualizações estaticas e que devem ser iniciadas ao executar o jogo, sendo elas a criação dos botões e adição a suas respectivas listas de acordo com o state do jogo que ira aparecer(**buttons.menu_state.play_game = Button("play game", startNewGame, nil)**, onde será criado um botão na lista de botões **menu_state** com nome **play_game**, o botão por sua vez sendo uma função em **Button.lua** recebe tres parametros, **function Button (text, func, func_param)**, seu texto, a função que ira realizar no _checkPressed()_ e caso tenha algum parametro para esta função o recebe tambem, sendo assim o botão *play_game* do menu do jogo, tem escrito play game e ao ser clicado ira iniciar um novo jogo atraves de _startNewGame()_), ao total são quatro botões para o **menu_state**, sendo eles **play game**, **settings** que _changeGameState_ para "configutations", **credits** que recebi _credit()_ e **exit game** que recebi **love.event.quit** uma função de _LOVE_ que para de a atual execução, tem também tres botões de **pontuacao_state** sendo **name:** sem função, um botão com a **variavel string _nome_** sem função tambem, ambos são botões por escolha estetica e o ultimo botão é o de **confirm** iniciado sem função, mas que ganha uma em **love.update()**, **ended_state** possui tres botões também sendo **replay game** com _starNewGame_, **menu** com _chageGameState()_ para "menu" e **exit game** também com mesmo atributos do com o mesmo nome em _menu_, em **paused_state** temos quatro botões, **resume** que _changeGameState_ para "running", **replay game**, **menu** e **exit** iquais aos outros botões de mesmo nome, apenas em outro state, e por fim os botões de **configurations_state** que são, **play_Stop_audio**, inicialmete aqui com nada escrito e sem funções, **Audio:** outro botão apenas estetico, uma sequencia de botões com texto **1 á 5**, todos com **changeVolume** com parametros _0.1_, _0.2_, _0.3_, _0.4_ e _0.5_ respectivamente, e o ultimo botão sendo o **back** com _changeGameState_ para "menu", outras alterações em _load_ são deixar o cursor original invisivel com **love.mouse.setVisible(false)** e adicionar o tempo inicial da execução, ja que existe a intro do jogo, em *time_init* com **love.timer.getTime()**. Em sequida temos o **love.update(dt)** como a segunda função base de _LOVE_, responsavel pelas atualizações com o dercorrer do tempo de exucação, usando como parametro o **dt(delta time)**, que seria a representação de frames por segundo, mas devido aos processadores atuais o valor é representado mais ou menos por 0,013, para que a skin do mouse sempre esteja aonde ele estiver a cada segundo, **mouse.mouse_x, mouse.mouse_y = love.mouse.getPosition()** indepedente do _state_, como visto o jogo tem duas teclas de comando e uma terceira para escrita em _pontuacao_(backspace), para um maior controle duas delas so funcionão ao soltar a tecla, usando a função **love.keyreleased(key)** aonde key sera a tecla, **se key == "space" and player.animation.jump == false and player.animation.hit == false and game.state["running"]** ou seja para pular e necessario soltar a tecla quando o personagem não estiver no meio de um pulo e nem atingido e obviamente o jogo estiver em _running_, então **player.animation.frame = 1**(reseta frame ja que são compartilhados de andar e pular), **player.animation.idle = true** e **player.animation.jump = true**(indicar que é um pulo e não andar) e a segunda tecla **se key == "backspace" and game.state["pontuacao"]** quando a tecla backspace conhecida para apagar textos for solta enquanto o jogo estiver em _pontuacao_, então **nome = string.sub(nome, 1, -2)**(a string _nome_ atraves do **string.sub** que permite manipular uma string, recortando uma nova string de outra, uma string normal vai de 1 a -1, ao colocar 1 a -2 a nova string tera todos caracteres menos o ultimo e ao salvar em _nome_ sobrescreve a alteração dando sensação que se apagou o ultimo digito), apois estas alterações, as proximas são divididas em _states_, **se game.state["intro1"]** então uma variavel chamada **time_count** ira quardar o tempo com **love.timer.getTime()** e devido a ser no update isso ira acontecer a cada segundo se em algum momento **time_count - time_init** for maior ou iqual a *time_space*(7.5 segundos) então primeiramente **time_init = time_count** e **changeGameState("intro2")**, depois disso vem **se game.state["intro2"]** então novamente *time_count* ira quardar o tempo a cada segundo e **se time_count - time_init** for maior ou iqual que *time_space* denovo então desta vez **changeGameState("menu")**, mudar das intros ate o menu depende apenas do tempo, depois sera pelos botões ou a derrota do jogador em "running", portanto o proximo é **se game.state["running"]** então começa indicando que tanto o jogador quanto o inimigo estão andando com **player.animation.idle = false** e **enemy.animation_e.idle = false**, a proxima atualização por segundo sem condição além do state "running", é a contagem de pontos **game.points = game.points + (dt * 8)** o valor de dt * 8 é o mais perto de 1 por segundo possivel, então este calculo faz com que _game.points_ aumente em 1 a cada segundo de "running" que se passe, achei importante que a proxima condição fosse a de derrota do jogador, que é **se enemy[1]:kill()**(a function **kill()** presente em _Lunna()_, devido ao inimigo não possuir hitbox apenas retorna verdadeiro **se self.x == -120** e falso se não) então ira verificar **se game.high_score** maior que **high_score_value**(primeiro lugar nos Json) ou maior que **file_data.pontuacao[2].high_score** ou que **file_data.pontuacao[3].high_score**(segundo e terceiro lugares), mas antes de pergunta sobre o segundo e o terceiro **#file_data.pontuacao < 3**(caso o tamanho do placar ainda for menor que 3), todas estas opções **changeGameState("pontuacao")**, mas caso tenha tres high_score e todos são maiores que o atual então **changeGameState("ended")**, alem de salvar a quantia de queijos da atual "running" no Json com **file_data.queijo = file_data.queijo + game.cheese_round**, **write("save", file_data)** e novamente importa os dados por questão de segurança **file_data = read("save")** e por fim caso _kill_ retorne falso, **enemy[1]:move(player.animation.hit, dt, enemy.callback)**(a function move em _Lunna_ funciona baseado em dois parametros internos da localização de x, e influencia de hit do jogador, dt e callback, aonde **se not hit** então ele fara duas coisas distintas, **se self.x** maior que -660(limite de recuo do inimigo) e **cb == 0** então **self.x = self.x - dt * 200**[se move da direita para esquerda sumindo eventualmente da tela], agora se principalmente **cb** maior que 0 então **self.x = self.x**[permanece no lugar], mas caso haja o _hit do jogador então **se self.x** menor que -120[limite de avanço, lembrando que -120 é _kill_] então **self.x = self.x + dt * 200** o inimigo avança, reaparecendo na tela), em sequida temos a verificação de todos objetos das listas *background_run*, _coletavel_ e _stone_ para fazer algumas alterações e principalmente acionar o _move_ de cada um, começando pelo mais simples, um loop de 1 ao **#stone**(tamanho da lista), **stone[l]:move(dt, player.animation.jump)**(lembrando que a dificuldade maxima e de 8, aonde a velocidade da pedra é **20 * level** se menor que 8 e se maior **20 * 8**, como o pulo no nivel 1 é incapaz de passar a pedra, mas achei ser a velocidade ideal de começo então o _mo0ve_ tem duas opções **se pulo**(personagem pulou) e **self.lvl < 2** então tanto a pedra em si **self.x** como sua hitbox **self.circle_x** seram iqual ao mesmo **- self.speed * (dt * 25) - self.lvl** e caso não esteja pulando no nivel 1 ou seja maior ou iqual ao nivel 2 pulando ou não então ambos serão diminuidos por **- self.speed * (dt * 10) - self.lvl**, tanto a primeira como a segunda opção a pedra ira aparecer devido aos parametros do proprio objeto no final da tela a direita e ira se mover dependendo destes **ifs** de _move_ e da **dificuldade do jogo** para extrema esquerda da tela), para lista _coletavel_ é basicamente o mesmo em _move_ de _Queijo_, e ao usar de 1 ao **#coletavel** faça **coletavel[i]:move(dt, player.animation.jump)**, a unica diferença e que o queijo possui uma peculiaridade por opção visual, de **se calculateDistance(stone[j].circle_x, stone[j].circle_y, coletavel[i].circle_x, coletavel[i].circle_y) <= coletavel[i].radius * 2** (hitbox do queijo e de alguma pedra presente na lista _stone_ estiverem sobrepostas) então tanto **coletavel[i].y** quanto o **coletavel[i].circle_y** iram diminuir de si mesmos - 10 como e um _if_ em _update_ ira acontecer ate não estarem mais sobrepostos, resumindo o queijo que estiver aparecido no mesmo lugar da pedra sera ejetado para cima dela, em uma velocidade impercerpitivel aos olhos humanos, e por fim a lista de *background_run*, ira verificar de 1 ao seu tamanho, inicialmente cria e armazena em **background_value** **CalculateComplement(background_run[a].totalwidth, background_run[a].width)** a função de _globals.lua_ que serve para saber o resto do background que esta fora de tela, com isso **se background_run[a].x** maior que **background_value**, e menor que **background_value + background_run[a].speed * (dt * 10)**(o valor fora de tela mais a velocidade do background em uma unidade, para que pegue o menor valor possivel em que o background esteja sem nada fora de tela levando em conta a velocidade de seu movimento indepedente da dificuldade) então **table_insert(background_run, BackGround(love.graphics.getWidth() - 1))**(insere na lista um novo background, no fim da tela) e enquanto o personagem não for atigido então **background_run[a]:move(dt)**, o **dt** de _update_ excelente para trabalhar com frames, e atualizações sequenciais ou rapidas, mas para atualizações singulares acaba apresentando problema, minha solução foi adicionar estas atualizações singulares dentre de outra atualização recorrente, no caso **se math.floor(game.points)** maior que **game.high_score** então **game.high_score = math.floor(game.points)**, atualização recorrente para o highscore da atual "running", mas quando a condição é preenchida não realiza mais nada ate o que estiver dentro estar concluido, ao adicionar atualizações singulares dentro dela, permite que estas so ativem uma vez, o que é o exemplo das alterações dentro do jogo rodando, começando com **se math.floor(game.points) % game.level_change[2] == 0 **(o simbolo % serve para achar o resto de uma divisão, logo todos multiplos de *level.change[2]*)